###############################################################################
#
# IAR C/C++ Compiler V6.40.1.950/W32 for MSP430           29/Mar/2017  17:22:33
# Copyright 1996-2015 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for Texas Instruments MSP430
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  regvar
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430
#    Source file   =  E:\_ARTON_PROJ\Arton-DL1-R\BP\soft\git\main.c
#    Command line  =  
#        E:\_ARTON_PROJ\Arton-DL1-R\BP\soft\git\main.c -lcN
#        E:\_ARTON_PROJ\Arton-DL1-R\BP\soft\git\IAR\Debug\List -o
#        E:\_ARTON_PROJ\Arton-DL1-R\BP\soft\git\IAR\Debug\Obj --debug
#        -D__MSP430G2433__ -e --double=32 --regvar_r4 --dlib_config "C:\Program
#        Files (x86)\IAR Systems\Embedded Workbench 7.3\430\lib\dlib\dl430fn.h"
#        -I ..\ -I .\ -Oh
#    List file     =  
#        E:\_ARTON_PROJ\Arton-DL1-R\BP\soft\git\IAR\Debug\List\main.lst
#    Object file   =  
#        E:\_ARTON_PROJ\Arton-DL1-R\BP\soft\git\IAR\Debug\Obj\main.r43
#
###############################################################################

E:\_ARTON_PROJ\Arton-DL1-R\BP\soft\git\main.c
      1          /**********************************************************************************
      2           *
      3           *      ASD-10QR MAIN routine
      4           * 
      5           **********************************************************************************
      6           * FileName:        main.c
      7           * Version:			1.00
      8           *
      9           * Processor:       MSP430G2xxx
     10           * Complier:        IAR Workbench for MSP430 v4.50 or higher
     11           *                  
     12           * Company:         ARTON
     13           *
     14           * Software License Agreement
     15           *
     16           * The software supplied herewith by ARTON Incorporated
     17           * (the "Company") for its devices is intended and
     18           * supplied to you, the Company's customer, for use solely and
     19           * exclusively on ARTON Inc products. The
     20           * software is owned by the Company and/or its Author, and is
     21           * protected under applicable copyright laws. All rights are reserved.
     22           * Any use in violation of the foregoing restrictions may subject the
     23           * user to criminal sanctions under applicable laws, as well as to
     24           * civil liability for the breach of the terms and conditions of this
     25           * license.
     26           *
     27           * THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES,
     28           * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
     29           * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
     30           * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
     31           * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
     32           * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
     33           *
     34           *
     35           * Author               Date      	Version	  		Comment
     36           *--------------------------------------------------------------------------------
     37           * Oleg Semeniuk	 16.01.2014    	1.00		Release for v1.00
     38           *
     39           *********************************************************************************/
     40          
     41          
     42          /*********************************************************************************/
     43          /*                                 INCLUDES                                      */
     44          /*********************************************************************************/
     45          
     46          
     47          #include <stdio.h>                    /* standard I/O .h-file                */
     48          #include <string.h>                   /* string and memory functions         */
     49          
     50          #include  "hardware.h"
     51          #include  "main.h"
     52          #include  "flash.h"
     53          #include  "type.h"
     54          #include  "delay.h"
     55          #include  "soft_uart.h"
     56          
     57          
     58          /*********************************************************************************/
     59          /*                                 VARIABLES                                     */
     60          /*********************************************************************************/
     61          
     62          __regvar __no_init tFlags 	f 	 @ __R4; 	// Set of state machine flags
     63          
     64          //
     65          u16		timerMain;					// Текущее значение главного таймера
     66          u16		timerLongPeriod;			// Таймер для режимa HUSH
     67          u16		mainPeriodCounter;			// Counter of main time period
     68          u16 	timerKeyDown;				// Для отслеживания нажатия на кнопку TEST
     69          u16		adc_data1[ADC_CH_DATA_LEN];	// Array for ADC samples
     70          
     71          u8 		DeviceMode; 				// Mode of device
     72          
     73          tFault	DeviceFault = {0};			// Current Faults flags
     74          tCalibrFault CalibrFault = {0};		// Calibration Faults flags
     75          u16 	dark;						// Level of dark signal
     76          u16 	delta;						// Current level signal
     77          
     78          u16 	delta_last = 0;				// Prev sygnal of delta
     79          u16		zero_timer = 0;				// Zero level signal timer
     80          
     81          u8		fault_chamber_counter = 0;	// Counter of series chamber fault
     82          u8  	FireMeasCount = 0;			// Количество замеров, превышающих порог Пожара
     83          
     84          // Variables for definition Long Term Drift
     85          u16  	DriftCounter = 0;
     86          u32 	DriftSumma = 0;
     87          u32 	DriftLevel;					// Current Long Term Drift Level
     88          	
     89          //u16 	FireLimit;					// Current Limit of Fire
     90          //u16 	PreFireLimit;				// Current Limit of PreFire
     91          	
     92          u16		CCR1_Value;					// CCR1 PWM duty cycle for sound generation
     93          u8 		Timer50msCounter = 0;		// Counter of 50ms ticks
     94          
     95          
     96          s16		signal_array[SIGNAL_ARRAY_LEN];
     97          
     98          //u8		AMP_Off_Timer = 0;
     99          
    100          
    101          volatile u32		led_r;
    102          volatile u32		led_y;
    103          volatile u32		led_sh = 0;
    104          
    105          u8 		fTimerA1_On = 0;
    106          
    107          
    108          #define CALIBR_STAGES		6
    109          u8 		calibr_stage;
    110          u16		s_array[CALIBR_STAGES];
    111          u8		q_array[CALIBR_STAGES];
    112          
    113          /* Old
    114          const u8 calibr_sequence[CALIBR_STAGES][3] = {
    115          //			 Amp_No	Gain  Reference
    116          			{  2,    3,     0 },
    117          			{  2,    3,     1 },
    118          			{  2,    2,     1 },
    119          			{  2,    1,     1 },
    120          			{  2,    0,     1 },
    121          			{  1,    0,     1 },
    122          			{  1,    0,     2 },
    123          };
    124          */
    125          
    126          const u8 calibr_sequence[CALIBR_STAGES][3] = {
    127          //			 Amp_No	Gain  Reference
    128          			{  1,    0,     2 },
    129          			//{  1,    0,     1 },
    130          			{  2,    0,     1 },
    131          			{  2,    1,     1 },
    132          			{  2,    2,     1 },
    133          			{  2,    3,     1 },
    134          			{  2,    2,     0 },
    135          };
    136          
    137          
    138          const u8 fault_sequence[4 * 2] = {MODE_FAULT, 10, MODE_NORM, 10, MODE_FIRE, 0, 0};	// 0 = ~~
    139          
    140          u8  fault_chain_ind = 0;	// 	
    141          u16 fault_chain_timer = 0;
    142          
    143          s8	gain;
    144          u8	amp_no;
    145          u8	reference;
    146          tCfgReg	cfg_reg;
    147          
    148          u8	jp1_state = 0;			// 0 - JP1 Open, 1 - JP1 Close
    149          
    150          u8	adc_process = 0;		// ADC low level semafore
    151          
    152          u16	light_timer = 0;		// For led lighting
    153          u8	light_sync = 0;			// For led lighting syncronisation
    154          
    155          u16	strob_pulse_timer = 0;	// Таймер ожидания электрической синхронизации
    156          u8	strob_fault_phase = 0;	// Фаза неисправности электрической синхронизации 0 - отключение БИ, 1 - включение БИ
    157          
    158          u16	hi_signal_counter  = 0;	// Very Hight signal counter
    159          
    160          u16	fault_timer = 0;		// Fault signal timer
    161          u8  fault_phase  = 0;		// Phase of  fault signal: 1 - break of BI , 0 - enable of  BI	
    162          
    163          u16 start_timer = 0;		// Start timer of device
    164          
    165          u16 flash_period_timer;		// Flast period timer
    166          
    167          
    168          
    169          
    170          
    171          /*********************************************************************************/
    172          /*                                FUNCTIONS                                      */
    173          /*********************************************************************************/
    174          // --- Declarations ---
    175          void ADC_MeasureInit(u8 input_no, u8 refer);
    176          u8   SignalAnalysis(void);
    177          void ADC_MeasureStart(void);
    178          void AMP_Calibration(void);
    179          
    180          u16  AverageData(u16 * data_ptr, u8 len);
    181          void SetRemoteAlarmMode(u8 sound);
    182          u8   RX_PacketParser(void);
    183          void ADC_Measure(u16 ch, u16 refout, u8 count);
    184          void ADC_Measure_TEMP(u16 ch, u16 refout, u8 count);
    185          
    186          void Timer_A1_Init(void);
    187          void Timer_A0_SetDelay(u16 period);
    188          void TimerA1_DelayUs(u16 time);
    189          void Timer_A0_Off(void);
    190          void JP1_Define(void);
    191          
    192          
    193          
    194          
    195          //--------------------------------------------------------------------------------
    196          // Function		: void VLO_TimerCalibr(void)
    197          // Parameters	: None
    198          // Return		: None
    199          // Description	: Calculation calibration value of VLO timer
    200          //--------------------------------------------------------------------------------
    201          void VLO_TimerCalibr(void) {
    202          	u16 clk;
    203          	
    204          	// Start timer 1MHz
    205          	TACTL = TASSEL_2 + MC_1 + ID_3;     	 	// SMCLK, up mode  / 8
    206          	//			
    207          	CCR0 = 62500 - 1;	                    // Period 0.5sec
    208          	CCTL1 = 0; 			                    // CCR1 reset/set
    209          	TACCTL0 = CCIE;							// Разрешаем прерывание таймера по достижению значения TACCCR0.
    210          	//
    211          	clk = 0;
    212          	while (1) {
    213          		if (fTimer50msOn) {
    214          			fTimer50msOn = 0;
    215          			clk++;
    216          		}
    217          		if (fTimerA_On) {
    218          			fTimerA_On = 0;
    219          			clk++;
    220          			break;
    221          		}
    222          	}
    223          	//
    224          	//SoundStop();							// Disable interrupts of timer
    225          	TACTL = 0;  
    226          	TACCTL0 = 0;				// Запрещаем прерывание таймера по достижению значения TACCCR0.
    227          	//
    228          	if (clk != CONFIG->timer_calibr) {
    229          		StoragePropertyWord(eeTIMER_CALIBR_OFFSET, clk * 2);
    230          		#if (CRC_ENABLE == 1)
    231          		SavePropertyCS();
    232          		#endif
    233          	}
    234          	//
    235          }
    236          
    237          
    238          //--------------------------------------------------------------------------------
    239          // Function		: void ClearDriftVar(void)
    240          // Parameters	: None
    241          // Return		: None
    242          // Description	: Clear Long Term Drift variables
    243          //--------------------------------------------------------------------------------
    244          void ClearDriftVar(void) {
    245          	DriftCounter = 0;
    246          	DriftSumma = 0;
    247          	DriftLevel = 0;
    248          }
    249          
    250          
    251          
    252          //--------------------------------------------------------------------------------
    253          // Function		: void SetLimitCompens(void)
    254          // Parameters	: fire_level - fire level in increment
    255          // Return		: None
    256          // Description	: Setting limit compensation level
    257          //--------------------------------------------------------------------------------
    258          void SetLimitCompens(void) {
    259          	u16 norm = CONFIG->limit_norm;
    260          	//
    261          	StoragePropertyWord(eeLIMIT_LONG_DRIFT_OFFSET, norm / 2);
    262          	//
    263          #if (CRC_ENABLE == 1)
    264          	SavePropertyCS();
    265          #endif
    266          	//
    267          	ClearDriftVar();
    268          	//
    269          }
    270          
    271          
    272          
    273          //--------------------------------------------------------------------------------
    274          // Function		: void SetLevels(u16 norm)
    275          // Parameters	: norm - norm sygnal level 
    276          // Return		: None
    277          // Description	: Calculation and setting levels depending on background signal
    278          //--------------------------------------------------------------------------------
    279          void SetLevels(u16 norm) {
    280          	u16 temp;
    281          	u8  d;	
    282          	StoragePropertyWord(eeLIMIT_NORM_OFFSET, norm);
    283          	//
    284          	d = norm * 28 / 100;
    285          	//
    286          	temp = norm - d;		//
    287          	StoragePropertyWord(eeLIMIT_FIRE_OFFSET, temp);
    288          	//
    289          	temp = norm - d * 3 / 4;		//
    290          	StoragePropertyWord(eeLIMIT_PREFIRE_OFFSET, temp);
    291          	
    292          	//
    293          #if (CRC_ENABLE == 1)
    294          	SavePropertyCS();
    295          #endif
    296          	//
    297          	ClearDriftVar();
    298          	//
    299          }
    300          
    301          
    302          
    303          //--------------------------------------------------------------------------------
    304          // Function		: void SetLevels(u16 norm)
    305          // Parameters	: norm - norm sygnal level, nonlinearity_corr - correction 
    306          //				  nonlinearity in case of Hi signal (0 - none, 1 - low correction,
    307          //				  2 - hi correction)
    308          // Return		: None
    309          // Description	: Calculation and setting levels depending on background signal
    310          //--------------------------------------------------------------------------------
    311          void SetLevelsFromCalibr(u16 norm, u8 nonlinearity_corr) {
    312          	u16 temp;
    313          	u8  d;	
    314          	StoragePropertyWord(eeLIMIT_NORM_OFFSET, norm);
    315          	//
    316          	switch (nonlinearity_corr) {
    317          		case 0:
    318          			d = norm * 29 / 100;
    319          			break;
    320          		case 1:
    321          			d = norm * 23 / 100;
    322          			break;
    323          		case 2:
    324          			d = norm * 18 / 100;
    325          			break;
    326          		default:
    327          			d = norm * 29 / 100;
    328          	}
    329          	//
    330          	temp = norm - d;		//
    331          	StoragePropertyWord(eeLIMIT_FIRE_OFFSET, temp);
    332          	//
    333          	temp = norm - d * 3 / 4;		//
    334          	StoragePropertyWord(eeLIMIT_PREFIRE_OFFSET, temp);
    335          	
    336          	//
    337          #if (CRC_ENABLE == 1)
    338          	SavePropertyCS();
    339          #endif
    340          	//
    341          	ClearDriftVar();
    342          	//
    343          }
    344          
    345          
    346          
    347          //--------------------------------------------------------------------------------
    348          // Function		: void DeviceStart(void)
    349          // Parameters	: None
    350          // Return		: None
    351          // Description	: Function executes initialization variable at start of device
    352          //--------------------------------------------------------------------------------
    353          void DeviceStart(void) {
    354          
    355          	DeviceFault.byte = 0;		// Reset faults flags
    356          	CalibrFault.byte = 0;		// Reset faults flags
    357          	//		
    358          	VLO_TimerCalibr();			// Calibration VLO Timer
    359          	//
    360          	ClearDriftVar();
    361          	
    362          }
    363          
    364          
    365          //--------------------------------------------------------------------------------
    366          // Function		: void DefineFireLimit(void)
    367          // Parameters	: None
    368          // Return		: None
    369          // Description	: Determination fire and prefire limits depending on long term drift
    370          //--------------------------------------------------------------------------------
    371          //#pragma optimize=none
    372          u16 getZeroLevel(void) {
    373          	u16 ret;
    374          	//
    375          	ret = CONFIG->limit_norm / 6;
    376          	return ret;
    377          }
    378          
    379          
    380          //--------------------------------------------------------------------------------
    381          // Function		: u16 getTimerValue(u16 period_sec)
    382          // Parameters	: time_sec : time in sec (0..655)
    383          // Return		: None
    384          // Description	: Getting time in system ticks
    385          //--------------------------------------------------------------------------------
    386          static u16 getTimerValue(u16 time_sec) {
    387          	u16 time = 100;
    388          	
    389          	if (time_sec > 655) return 0;
    390          	
    391          	time *= time_sec;	
    392          	
    393          	return time;
    394          
    395          }
    396          
    397          
    398          //--------------------------------------------------------------------------------
    399          // Function		: void VLO_TimerCalibr(void)
    400          // Parameters	: None
    401          // Return		: None
    402          // Description	: Calculation calibration value of VLO timer
    403          //--------------------------------------------------------------------------------
    404          u16 VLO_GetPeriod(void) {
    405          	
    406          	// Start timer 8MHz
    407          	TACTL = TASSEL_2 + MC_1;           	 	// SMCLK, up mode
    408          	//			
    409          	CCR0 =0xFFFF;                    		// Period 2.5mS
    410          	CCTL1 = 0; 			                    // CCR1 reset/set
    411          	TACCTL0 = 0;							// Разрешаем прерывание таймера по достижению значения TACCCR0.
    412          	//
    413          	while (fTimer50msOn == 0) {}
    414          	fTimer50msOn = 0;
    415          	//while (fTimer50msOn == 0) {}
    416          	
    417          	return TAR;
    418          	
    419          }
    420          
    421          
    422          //--------------------------------------------------------------------------------
    423          // Function		: void VLO_TimerCalibr(void)
    424          // Parameters	: None
    425          // Return		: None
    426          // Description	: Calculation calibration value of VLO timer
    427          //--------------------------------------------------------------------------------
    428          void AMP_Gain_Init(void) {
    429          	
    430          	AMP_SetGain(CONFIG->Gain);
    431          	
    432          }
    433          
    434          #define ADC_AMP1	INCH_1		/* First AMP out */
    435          #define ADC_AMP2	INCH_0		/* Second AMP out */
    436          #define ADC_BUT		INCH_2		/* Tact button */
    437          #define ADC_AE		0x13		/* Analog (Input) Enable Control Register Value + VREF+*/
    438          #define ADC_AE_BUT	0x17		/* Analog (Input) Enable Control Register Value + Tact sw + VREF+*/
    439          
    440          #define ADC_FLUCTATION			20
    441          #define SIGNAL_0_LEVEL			512
    442          
    443          #define CORREL_LEVEL			120		/* Threshold level to correlations of the start signal */
    444          
    445          
    446          
    447          //--------------------------------------------------------------------------------
    448          // Function		: ADC_Measure(u8 input_no, u8 refer)
    449          // Parameters	: input_no - number AMP output (= 1 or 2), refer - reference voltage (=0 - 1.5V, =1 - 2.5V, =2 - 3.3V)
    450          // Return		: None
    451          // Description	: Функция производит измерения по выбранному каналу ADC и помещает их в массив adc_data1
    452          //				   ~109 kS/s for 16 MHz 
    453          //--------------------------------------------------------------------------------
    454          void ADC_MeasureInit(u8 input_no, u8 refer) {
    455          	
    456          	ADC10CTL0 &= ~ENC;
    457          	while (ADC10CTL1 & BUSY);             	// Wait if ADC10 core is active 
    458          	//
    459          	switch ((Ref_Type)refer) {
    460          		case REF_1_5V:  
    461          			ADC10CTL0 = SREF_1 + ADC10SHT_1 + MSC + REFOUT + REFON + ADC10ON + ADC10IE;				// Sample&hold = 8 x ADC10CLKs
    462          			break;
    463          		case REF_2_5V:  
    464          			ADC10CTL0 = SREF_1 + ADC10SHT_1 + MSC + REFOUT + REFON + ADC10ON + ADC10IE + REF2_5V;	// Sample&hold = 8 x ADC10CLKs
    465          			break;
    466          		case REF_3_3V:  
    467          			ADC10CTL0 = SREF_0 + ADC10SHT_1 + MSC + REFOUT + REFON +ADC10ON + ADC10IE  +  REF2_5V;	// Sample&hold = 8 x ADC10CLKs
    468          			break;
    469          	}
    470          	//
    471          	DelayUs(50);	
    472          	//
    473          	ADC10DTC1 = SIGNAL_ARRAY_LEN;	//ADC_SAMPLES_NUMBER;			// count of conversions
    474          	//
    475          	if (input_no == 1) {
    476          //		ADC10CTL1 = ADC10SSEL_2 + ADC10DIV_7 + CONSEQ_2 + ADC_AMP1;     // MCLK + ADC10 Clock Divider Select 6 (DIV = 7),  Input 1
    477          			ADC10CTL1 = ADC10SSEL_3 + ADC10DIV_7 + CONSEQ_2 + ADC_AMP1;     // MCLK + ADC10 Clock Divider Select 6 (DIV = 7),  Input 1
    478          			}else{
    479          //		ADC10CTL1 = ADC10SSEL_2 + ADC10DIV_7 + CONSEQ_2 + ADC_AMP2;     // MCLK + ADC10 Clock Divider Select 6 (DIV = 7),  Input 2
    480          			ADC10CTL1 = ADC10SSEL_3 + ADC10DIV_7 + CONSEQ_2 + ADC_AMP2;     // MCLK + ADC10 Clock Divider Select 6 (DIV = 7),  Input 1
    481          	}
    482          	
    483          	ADC10AE0 |= ADC_AE;                     // A0 & A1 ADC option select
    484          	//
    485          }
    486          
    487          
    488          //--------------------------------------------------------------------------------
    489          // Function		: ADC_Measure(u16 ch, u16 refout, u8 count)
    490          // Parameters	: ch - ADC channel, refout - 0 or REFOUT, count - кол-во измерений 
    491          // Return		: None
    492          // Description	: Функция производит измерения по выбранному каналу ADC и помещает их в массив adc_data1
    493          //--------------------------------------------------------------------------------
    494          void ADC_MeasureStart(void) {
    495          	__disable_interrupt();		// Disable interrupt
    496          	
    497          	adc_process = 1;
    498          	
    499          	//ADC10SA = (u16) &signal_array[SIGNAL_ARRAY_LEN - ADC_SAMPLES_NUMBER];      	// Data buffer start - end of sygnal_array
    500          	ADC10SA = (u16) &signal_array[0];	// Data buffer start - end of sygnal_array
    501          	ADC10CTL0 |= ENC + ADC10SC;         // Sampling and conversion start
    502          	//
    503          	
    504          	__enable_interrupt();                     // enable interrupts
    505          }
    506          
    507          
    508          
    509          u16 last_0_level;
    510          u16 last_level;
    511          
    512          //--------------------------------------------------------------------------------
    513          // Function		: void VLO_TimerCalibr(void)
    514          // Parameters	: None
    515          // Return		: 0 - no valid array, 1
    516          // Description	: The analysis of the input signal on ADC_SAMPLES_NUMBER samples
    517          //--------------------------------------------------------------------------------
    518          u16 AbsValue(u16 x1, u16 x2) {
    519          	if (x1 >= x2) {
    520          		return (x1 - x2);
    521          	}else{
    522          		return (x2 - x1);
    523          	}
    524          }
    525          
    526          /**************************************************************
    527          WinFilter version 0.8
    528          http://www.winfilter.20m.com
    529          akundert@hotmail.com
    530          
    531          Filter type: Band Pass
    532          Filter model: Butterworth
    533          Filter order: 8
    534          Sampling Frequency: 109 KHz
    535          Fc1 and Fc2 Frequencies: 3.800000 KHz and 14.000000 KHz
    536          Coefficents Quantization: 8-bit
    537          
    538          Z domain Zeros
    539          z = -1.000000 + j 0.000000
    540          z = -1.000000 + j 0.000000
    541          z = -1.000000 + j 0.000000
    542          z = -1.000000 + j 0.000000
    543          z = -1.000000 + j 0.000000
    544          z = -1.000000 + j 0.000000
    545          z = -1.000000 + j 0.000000
    546          z = -1.000000 + j 0.000000
    547          z = 1.000000 + j 0.000000
    548          z = 1.000000 + j 0.000000
    549          z = 1.000000 + j 0.000000
    550          z = 1.000000 + j 0.000000
    551          z = 1.000000 + j 0.000000
    552          z = 1.000000 + j 0.000000
    553          z = 1.000000 + j 0.000000
    554          z = 1.000000 + j 0.000000
    555          
    556          Z domain Poles
    557          z = 0.644814 + j -0.260807
    558          z = 0.644814 + j 0.260807
    559          z = 0.756494 + j -0.196546
    560          z = 0.756494 + j 0.196546
    561          z = 0.587475 + j -0.386644
    562          z = 0.587475 + j 0.386644
    563          z = 0.840396 + j -0.195195
    564          z = 0.840396 + j 0.195195
    565          z = 0.588237 + j -0.523443
    566          z = 0.588237 + j 0.523443
    567          z = 0.901607 + j -0.202202
    568          z = 0.901607 + j 0.202202
    569          z = 0.951542 + j -0.212108
    570          z = 0.951542 + j 0.212108
    571          z = 0.642148 + j -0.658914
    572          z = 0.642148 + j 0.658914
    573          ***************************************************************/
    574          
    575          #define Ntap 18
    576          
    577          // !!! See division by DCgain below
    578          #define DCgain 512	
    579          
    580          //const s16 FIRCoef[Ntap] = { 
    581          const s8 FIRCoef[Ntap] = { 
    582                    -13,
    583                    -32,
    584                    -52,
    585                    -59,
    586                    -43,
    587                     -2,
    588                     50,
    589                     95,
    590                    113,
    591                     95,
    592                     50,
    593                     -2,
    594                    -43,
    595                    -59,
    596                    -52,
    597                    -32,
    598                    -13,
    599                     -3
    600          };
    601          
    602          
    603          static s16 	x[Ntap] = {0};	//, 512, 512, 512 }; 	//input samples
    604          
    605          s16 fir_filter(s16 sample) {
    606              s32	 		y = 0;      //output sample
    607              int 		i;
    608          	
    609              // Shift the old samples
    610              for(i = Ntap-1; i > 0; i--) {
    611          		x[i] = x[i-1];
    612          	}
    613          	
    614              // Calculate the new output
    615              x[0] = sample;
    616              for(i = 0; i < Ntap; i++) {
    617          		y += (s32)FIRCoef[i] * x[i];
    618          	}
    619          	
    620          	if (y >= 0) {
    621          		y = y >> 9;
    622          	}else{
    623          		y = y / DCgain;	
    624          	}
    625          	
    626              return y;	// / DCgain;
    627          }
    628          
    629          
    630          
    631          
    632          //--------------------------------------------------------------------------------
    633          // Function		: void VLO_TimerCalibr(void)
    634          // Parameters	: None
    635          // Return		: 0 - no signal, 1 - signal is existing
    636          // Description	: The analysis of the input signal on ADC_SAMPLES_NUMBER samples
    637          //--------------------------------------------------------------------------------
    638          u8 DefineNewMode(u16 delta) {
    639          	
    640          	return 0;
    641          }
    642          
    643          
    644          //s16	adc_back1[ADC_SAMPLES_NUMBER];
    645          
    646          volatile s16	d1, d2, d3, d4;
    647          
    648          #define EXT_ARRAY_LEN	7
    649          
    650          //--------------------------------------------------------------------------------
    651          // Function		: u8 SignalAnalysis(void)
    652          // Parameters	: None
    653          // Return		: 0 - no signal, 1 - signal is existing
    654          // Description	: The analysis of the input signal on ADC_SAMPLES_NUMBER samples
    655          //--------------------------------------------------------------------------------
    656          //#pragma optimize=none
    657          u8 SignalAnalysis(void) {
    658          	int i;
    659          	s16	sample;
    660          	s16 min = 2048, max = -2048;
    661          	int i_min = 0, i_max = 0;
    662          	u8 array_hi[EXT_ARRAY_LEN];
    663          	u8 array_lo[EXT_ARRAY_LEN];
    664          	u8 i_hi = 0;
    665          	u8 i_lo = 0;
    666          	s8 T = 0;
    667          	u8 ret = 0;
    668          	
    669          	// 
    670              for(i = 1; i < Ntap; i++) {
    671          		x[i] = 0;	//signal_array[i] - 220;
    672          	}
    673          	
    674          	sample = AverageData((u16 *)&signal_array[0], 16);
    675          	
    676          	// Filtering with use FIR
    677          	for (i = 0; i < SIGNAL_ARRAY_LEN; i++) {
    678          		//signal_array[i] = fir_filter(adc_data1[j++] - 512);
    679          		signal_array[i] = fir_filter(signal_array[i] - sample);	
    680          	}
    681          	
    682          	
    683          	// Searching for of importance of the amplitude of the signal on possible gap of time
    684          	for (i = 15; i < SIGNAL_ARRAY_LEN - 2; i++) {
    685          		sample = signal_array[i];
    686          		if (((sample >  signal_array[i - 1]) && (sample >  signal_array[i + 1]) && (sample > signal_array[i - 2]) && (sample > signal_array[i + 2])) ||
    687          		    ((sample >  signal_array[i - 1]) && (sample == signal_array[i + 1]) && (sample > signal_array[i - 2]) && (sample > signal_array[i + 2])) || 
    688          			((sample == signal_array[i - 1]) && (sample == signal_array[i + 1]) && (sample > signal_array[i - 2]) && (sample > signal_array[i + 2])) )   {
    689          	
    690          			if (sample > 10) {	
    691          				array_hi[i_hi] = i;
    692          				if (i_hi < EXT_ARRAY_LEN - 1) i_hi++;
    693          			}
    694          		}
    695          		
    696          		if (((sample <  signal_array[i - 1]) && (sample <  signal_array[i + 1]) && (sample < signal_array[i - 2]) && (sample < signal_array[i + 2])) ||
    697          		    ((sample <  signal_array[i - 1]) && (sample == signal_array[i + 1]) && (sample < signal_array[i - 2]) && (sample < signal_array[i + 2])) || 
    698          			((sample == signal_array[i - 1]) && (sample == signal_array[i + 1]) && (sample < signal_array[i - 2]) && (sample < signal_array[i + 2])) )   {
    699          		
    700          			if (sample < (-10)) {	
    701          				array_lo[i_lo] = i;
    702          				if (i_lo < EXT_ARRAY_LEN - 1) i_lo++;
    703          			}
    704          			
    705          		}
    706          			
    707          		if (sample < min) {
    708          			min = sample;
    709          			i_min = i;
    710          		}
    711          		if (sample > max) {
    712          			max = sample;
    713          			i_max = i;
    714          		}
    715          	}
    716          
    717          	//
    718          	delta = 0;
    719          	
    720          	// Filtering
    721          	
    722          	if ((i_lo < 2) || (i_hi < 3)) {
    723          		// Low signal
    724          		ret = 1;
    725          	}else{
    726          		T = array_hi[1] - array_hi[0];
    727          		if ((T < 9) || (T > 15))  {
    728          			// High signal
    729          			ret = 2;
    730          		}
    731          	}
    732          	
    733          	d1 = signal_array[array_hi[0]] - signal_array[array_hi[1]];
    734          	if (((d1 < -50) || (d1 > 50)) && (amp_no == 1)){
    735          		// Wery high signal
    736          		ret = 2;
    737          	}
    738          	
    739          	// Definition of delta
    740          	// Define of first low extremum after first hi extremum
    741          	for (i = 0; i < EXT_ARRAY_LEN; i++) {
    742          		if (array_lo[i] > array_hi[0]) {
    743          			i_hi = 0;
    744          			i_lo = i;
    745          			break;
    746          		}
    747          	}
    748          	//
    749          	/* ////
    750          	i_hi++;
    751          	d1 = signal_array[array_hi[i_hi++]] - signal_array[array_lo[i_lo++]];
    752          	d2 = signal_array[array_hi[i_hi]] - signal_array[array_lo[i_lo]];
    753          	delta = (d1 + d2) / 2;
    754          	*/
    755          	
    756          	//i_lo++;
    757          	d1 = signal_array[array_hi[i_hi++]] - signal_array[array_lo[i_lo]];
    758          	d2 = signal_array[array_hi[i_hi]] - signal_array[array_lo[i_lo++]];
    759          	d3 = signal_array[array_hi[i_hi++]] - signal_array[array_lo[i_lo]];
    760          	d4 = signal_array[array_hi[i_hi]] - signal_array[array_lo[i_lo]];
    761          
    762          	delta = (d1 + d2 + d3 + d4) / 4;
    763          	
    764          	if (delta > 4000) {
    765          		delta = 0;	//CONFIG->limit_norm;
    766          	}
    767          	
    768          	if ((DeviceMode == MODE_CALIBR) && ret) {
    769          		delta = 0;
    770          	}
    771          	//
    772          	return ret;
    773          }
    774          
    775          
    776          
    777          //--------------------------------------------------------------------------------
    778          // Function		: void Timer_A0_SetDelay(u16 period)
    779          // Parameters	: period in us (1..65535) - for 8 MHz DCO
    780          // Return		: None
    781          // Description	: Function initiates delay
    782          //--------------------------------------------------------------------------------
    783          void Timer_A0_SetDelay(u16 period) {
    784          	
    785          	if (period == 0) return;
    786          	
    787          	_BIC_SR(GIE);    					// Запрещаем прерывания
    788          	
    789          	fTimerA_Enable = 1;
    790          	fTimerA_Repeat = 0;
    791          	//
    792          	TA0R = 0;
    793          	TACTL 	 = TASSEL_2 + MC_1 + ID_3;  // SMCLK, up mode, div = 8
    794          	CCR0 	 = period - 1;      		// Period T(us) * F(MHz)
    795          	TACCTL0 = CCIE;						// Разрешаем прерывание таймера по достижению значения TACCCR0.
    796          	//
    797          	_BIS_SR(GIE);    					// Разрешаем прерывания
    798          }
    799          
    800          //--------------------------------------------------------------------------------
    801          // Function		: void TimerA1_DelayUs(u16 time)
    802          // Parameters	: period in us (1..32768) - for 1 MHz DCO
    803          // Return		: None
    804          // Description	: Function initiates 
    805          //--------------------------------------------------------------------------------
    806          #pragma optimize=none
    807          void TimerA1_DelayUs(u16 time) {
    808          	_BIC_SR(GIE);    					// Запрещаем прерывания
    809          	
    810          	//
    811          	TA1R = 0;
    812          	TA1CTL 	 = TASSEL_2 + MC_1;     	// SMCLK, up mode, div = 8
    813          	TA1CCR0 	 = time - 1 - 35;      	// Period T(us) * F(MHz)
    814          	//
    815          	_BIS_SR(GIE);    					// Разрешаем прерывания
    816          	
    817          	while ((TA1CCTL0 & CCIFG) == 0);
    818          	
    819          	TA1CTL 	 = 0;
    820          	TA1CCTL0 = 0;
    821          
    822          	/*
    823          	TA1R = 0;
    824          	TA1CTL 	 = TASSEL_2 + MC_1 + ID_0;  // SMCLK, up mode, div = 1
    825          	TA1CCR0  = SYS_TICK_TIME - 1;   	// Period T(us) * F(MHz)
    826          	*/
    827          }
    828          
    829          
    830          //--------------------------------------------------------------------------------
    831          // Function		: void Timer_A1_Init(void)
    832          // Parameters	: period in us (1..65535) - for 1 MHz DCO
    833          // Return		: None
    834          // Description	: Function initiates delay
    835          //--------------------------------------------------------------------------------
    836          void Timer_A1_Init(void) {
    837          	_BIC_SR(GIE);    					// Запрещаем прерывания
    838          	//
    839          	TA1R = 0;
    840          	TA1CTL 	 = TASSEL_2 + MC_1 + ID_0;  // SMCLK, up mode, div = 1
    841          	TA1CCR0  = SYS_TICK_TIME - 1;   	// Period T(us) * F(MHz)
    842          	TA1CCTL0 = CCIE;					// Разрешаем прерывание таймера по достижению значения TACCCR0.
    843          	//
    844          	_BIS_SR(GIE);    					// Разрешаем прерывания
    845          }
    846          
    847          
    848          //--------------------------------------------------------------------------------
    849          // Function		: void SoundStart(u8 snd_ind)
    850          // Parameters	: period in us (1..32768) - for 16 MHz DCO
    851          // Return		: None
    852          // Description	: Function initiates 
    853          //--------------------------------------------------------------------------------
    854          void Timer_A0_Off(void) {
    855          	_BIC_SR(GIE);    			// Запрещаем прерывания
    856          	//	
    857          	fTimerA_Enable = 0;
    858          	fTimerA_Repeat = 0;
    859          	//
    860          	TACTL = 0;  
    861          	TACCTL0 = 0;				// Запрещаем прерывание таймера по достижению значения TACCCR0.
    862          	//
    863          	_BIS_SR(GIE);    			// Разрешаем прерывания
    864          
    865          }
    866          
    867          
    868          //--------------------------------------------------------------------------------
    869          // Function		: void SetFaultMode(void)
    870          // Parameters	: None
    871          // Return		: None
    872          // Description	: 
    873          //--------------------------------------------------------------------------------
    874          void SetFaultMode(void) {
    875          	
    876          	DeviceMode = MODE_FAULT;
    877          	//
    878          	if (fault_timer == 0) { 
    879          		// No faults
    880          		fault_timer = 1000;		// 10 sec
    881          		fault_phase = 1;		// Break of BI
    882          	}
    883          	//
    884          	strob_pulse_timer = 0;		// Clear strob timer because there is breaking BI
    885          }
    886          
    887          
    888          
    889          //--------------------------------------------------------------------------------
    890          // Function		: void FaultSignalManager(void)
    891          // Parameters	: None
    892          // Return		: None
    893          // Description	: Call one time per 10 ms
    894          //--------------------------------------------------------------------------------
    895          void FaultSignalManager(void) {
    896          	
    897          	if ((DeviceMode == MODE_FIRE) || (DeviceMode == MODE_TEST) || (DeviceMode == MODE_CALIBR)) {
    898          		return;
    899          	}
    900          	//
    901          	if (DeviceFault.byte) {
    902          		DeviceMode = MODE_FAULT;
    903          		led_r = 0;
    904          		
    905          		if (DeviceFault.fStrobNone) {
    906          			// Electrical sync is fault
    907          			led_y = LED_PULSE_2;
    908          		}else
    909          		if (DeviceFault.fSignal_Low) {
    910          			// Level signal is very low
    911          			led_y = LED_PULSE_1;
    912          		}else	
    913          		if (DeviceFault.fFaultDrift) {
    914          			// Long Term Drift fault
    915          			led_y = LED_PULSE_3;
    916          		}else	
    917          		if (DeviceFault.fSignal_Hi) {
    918          			// Level signal is very big
    919          			led_y = LED_PULSE_5;
    920          		}
    921          		
    922          	}
    923          	
    924          	if (CalibrFault.byte) {
    925          		// Calibration fault signals
    926          		
    927          		DeviceMode = MODE_FAULT;
    928          		led_r = 0;
    929          		
    930          		if (CalibrFault.fCalibr_Low) {
    931          			led_y = LED_PULSE_4;
    932          		}else
    933          		if (CalibrFault.fCalibr_Hi) {
    934          			led_y = LED_PULSE_5;
    935          		}
    936          		//
    937          		BREAK_ENABLE();				// Disable of BI
    938          		FIRE_CLR();					// Disable Fire current consumption
    939          		//
    940          		fault_timer = 0;
    941          		fault_phase = 0;
    942          	}
    943          		
    944          	if ((DeviceFault.byte == 0) && (CalibrFault.byte == 0)) {
    945          		if (DeviceMode == MODE_FAULT) {
    946          			DeviceMode = MODE_NORM;
    947          			
    948          			led_r = 0;
    949          			led_y = 0;
    950          			
    951          			fault_timer = 0;
    952          			fault_phase = 0;
    953          			
    954          			strob_pulse_timer = 0;
    955          			
    956          			BREAK_DISABLE();		// Enable of BI
    957          			FIRE_CLR();				// Disable Fire current consumption
    958          		}
    959          	}
    960          	//
    961          	if (fault_timer) {
    962          		fault_timer--;
    963          		//
    964          		if (fault_timer == 0) {
    965          			if (fault_phase) {
    966          				fault_phase = 0;
    967          				fault_timer = 2000;		// 20 sec
    968          			}else{
    969          				fault_phase = 1;
    970          				fault_timer = 1000;		// 10 sec
    971          			}
    972          		}
    973          		//
    974          		if (fault_phase == 1) {
    975          			BREAK_ENABLE();			// Disable of BI
    976          		}else{
    977          			BREAK_DISABLE();		// Enable of BI
    978          		}
    979          
    980          	}
    981          }
    982          
    983          
    984          //--------------------------------------------------------------------------------
    985          // Function		: void LedTestValueManager(void)
    986          // Parameters	: None
    987          // Return		: None
    988          // Description	: 
    989          //--------------------------------------------------------------------------------
    990          //#pragma optimize=none
    991          void LedTestValueManager(void) {
    992          	if (delta < 150) {
    993          		led_r = LED_PULSE_1;
    994          		led_y = LED_FULL;
    995          	}else
    996          	if (delta < 250) {
    997          		led_r = LED_PULSE_2;
    998          		led_y = LED_FULL;
    999          	}else
   1000          	if (delta < 450) {
   1001          		led_r = LED_PULSE_3;
   1002          		led_y = LED_FULL;
   1003          	}else
   1004          	if (delta < 550) {
   1005          		led_r = LED_PULSE_4;
   1006          		led_y = LED_FULL;
   1007          	}else{
   1008          		led_r = LED_PULSE_5;
   1009          		led_y = LED_FULL;
   1010          	}
   1011          }
   1012          
   1013          
   1014          //---------------------------------------------------------------------------------
   1015          // Function		: void AMP_SetGain(u8 value)
   1016          // Parameters	: None
   1017          // Return		: None
   1018          // Description	: Initialization interrupts from RX Sniff CC112x (GPIO2)
   1019          //---------------------------------------------------------------------------------
   1020          void ADC_SetParam(void) {
   1021          	
   1022          	gain = CONFIG->Gain & 0x0F;
   1023          	reference = CONFIG->Gain >> 4;
   1024          	amp_no = CONFIG->AMP_No;
   1025          	
   1026          }
   1027          
   1028          //---------------------------------------------------------------------------------
   1029          // Function		: void AMP_SetGain(u8 value)
   1030          // Parameters	: None
   1031          // Return		: None
   1032          // Description	: Initialization interrupts from RX Sniff CC112x (GPIO2)
   1033          //---------------------------------------------------------------------------------
   1034          #pragma optimize=none
   1035          void CalibrationResultAnalise(void) {
   1036          	int i;
   1037          	u16 prev, temp, min = 0xFFFF, max = 0;
   1038          	u8  i_ok = 0xFF, i_ok2 = 0xFF;
   1039          	u8  fault = 0;
   1040          	u16 d;
   1041          	u8  corr = 0;
   1042          	
   1043          	prev = s_array[0];
   1044          	for (i = 0; i < CALIBR_STAGES; i++) {
   1045          		temp = s_array[i];
   1046          		//
   1047          		if (temp > max) {
   1048          			max = temp;
   1049          		}
   1050          		if (temp < min) {
   1051          			min = temp;
   1052          		}
   1053          			
   1054          		if (((temp >= 90) && (temp <= 200)) || 
   1055          			((temp >= 480) && (temp <= 600))) {
   1056          			i_ok = i;
   1057          		}
   1058          		if ((temp >= 200) && (temp <= 480)) {
   1059          			i_ok2 = i;
   1060          		}
   1061          		//
   1062          		if ((prev > 100) && (temp == 0) && (i <= 4)) {
   1063          			fault = 1;	// Signal is vefy Hi
   1064          		}
   1065          		prev = temp;
   1066          	}
   1067          	//
   1068          	if (q_array[0] == 2) {
   1069          		// Signal is vefy Hi
   1070          		fault = 1;
   1071          	}
   1072          	//
   1073          		
   1074          	if (fault) {
   1075          		// End of calibration - very Hi signal - ERROR
   1076          		//DeviceFault.fSignal_Hi = 1;
   1077          		//DeviceMode = MODE_FAULT;
   1078          		CalibrFault.fCalibr_Hi = 1;
   1079          	}else
   1080          	if ((i_ok2 < CALIBR_STAGES) || (i_ok < CALIBR_STAGES)) {
   1081          		if (i_ok2 < CALIBR_STAGES) {
   1082          			i = i_ok2; 
   1083          		}else{
   1084          			i = i_ok;
   1085          		}
   1086          		//
   1087          		// Calibration Ok!!!
   1088          		//
   1089          		d = s_array[i];
   1090          		//q = q_array[i]; 
   1091          		//
   1092          		if (i == 0) {
   1093          			if (d >= 480) {
   1094          				CalibrFault.fCalibr_Hi = 1;
   1095          				StoragePropertyByte(eeCALIBR_FAULT_OFFSET, CalibrFault.byte);
   1096          				return;
   1097          			}
   1098          			//
   1099          			if (d >= 330) {
   1100          				corr = 2;
   1101          			}else
   1102          			if (d >= 170) {
   1103          				corr = 1;
   1104          			}
   1105          		}
   1106          			
   1107          		// That's Ok
   1108          		//SetLevels(d);
   1109          		SetLevelsFromCalibr(d, corr);
   1110          		SetLimitCompens();
   1111          		
   1112          		amp_no = calibr_sequence[i][0];
   1113          		gain = calibr_sequence[i][1];
   1114          		reference = calibr_sequence[i][2];
   1115          		
   1116          		StoragePropertyByte(ee_GAIN, gain + (reference << 4));
   1117          		StoragePropertyByte(ee_AMP_NO, amp_no);
   1118          		StoragePropertyWord(eeCONFIG_REG_OFFSET, cfg_reg.word);
   1119          		//
   1120          		DeviceMode = MODE_NORM;
   1121          		//...
   1122          		FIRE_CLR();				// Disable Fire current consumption
   1123          		//
   1124          		AMP_SetGain(gain);
   1125          		//
   1126          	}else
   1127          	if (max < SYGNAL_MIN_VALUE) {
   1128          		// Signal is Low
   1129          		CalibrFault.fCalibr_Low = 1;
   1130          	}else
   1131          	if (min > SYGNAL_MAX_VALUE) {
   1132          		// Signal is Hi
   1133          		CalibrFault.fCalibr_Hi = 1;
   1134          	}
   1135          	//
   1136          	FIRE_CLR();				// Disable Fire current consumption
   1137          	StoragePropertyByte(eeCALIBR_FAULT_OFFSET, CalibrFault.byte);
   1138          }
   1139          	
   1140          
   1141          //========================================================
   1142          //                 ---  M A I N  ----
   1143          //========================================================
   1144          //--------------------------------------------------------------------------------
   1145          // Function		: void main(void)
   1146          // Parameters	: None
   1147          // Return		: None
   1148          // Description	: Main function. Contains main loop.
   1149          //--------------------------------------------------------------------------------
   1150          void main(void) {
   1151          	u8	byte, sh, len;
   1152          	int i;
   1153          	u8  loc_buf[2];
   1154          	u8  n_counter = 0;
   1155          	u8  quality;
   1156          	u16	summa = 0;
   1157          	u8	fire_level_counter = 0;
   1158          	u8	QualityFaultCounter = 0;
   1159          	u8	led_clk;
   1160          	u16	led_timer = 0;
   1161          	u8	timerA1_blank = 0;
   1162          	
   1163          	// Initialization variables and GPIO
   1164          	WDTCTL = WDTPW + WDTHOLD;				// отключаем сторожевой таймер
   1165          	// GIPIO Init
   1166          	GPIO_Init();
   1167          		
   1168          	// Init internal RC osc.
   1169          	BCSCTL1 = CALBC1_1MHZ; 					// Используем частоту 1 MГц
   1170          	DCOCTL =  CALDCO_1MHZ;
   1171          	
   1172          	DelayMs(100);
   1173          	
   1174          	// Initialization code for VLO
   1175          	__set_R4_register(0);
   1176          	//
   1177          	BCSCTL3 |= LFXT1S_2;                    // Select VLO as low freq clock
   1178          	// End initialization code
   1179          	
   1180          	WDTCTL = WDT_ADLY_1000;                   // Interval timer	/* for 50 ms */
   1181          	//WDTCTL = WDT_ADLY_1_9;                   // Interval timer	/* for 5.9 ms */
   1182          	IE1 |= WDTIE;                           // Enable WDT interrupt
   1183          	//
   1184          	if (IFG1 & WDTIFG) {
   1185          		// Reset WDT
   1186          		#if (SYS_FAULT_ENABLE == 1)
   1187          		DeviceFault.fFaultSWReset = 1;
   1188          		#endif
   1189          	}
   1190          	IFG1 = 0;
   1191          	//	
   1192          	DeviceMode = MODE_NORM;
   1193          	
   1194          	sleep();
   1195          	
   1196          //	DelayMs(2000);
   1197          	
   1198          	Led_Flash(10);
   1199          	DelayMs(300);
   1200          	Led_Flash(10);
   1201          	
   1202          	BREAK_DISABLE();					// Enable BI
   1203          //	DelayMs(7000);
   1204          	sleep();
   1205          	
   1206          	_BIS_SR(GIE);    					// Interrupt enable
   1207          	DeviceStart();
   1208          
   1209          	AMP_SetGain(CONFIG->Gain);
   1210          	ADC_SetParam();
   1211          	cfg_reg = CONFIG->config_reg;
   1212          	
   1213          	STROB_IE_Enable();
   1214          	Timer_A1_Init();
   1215          	
   1216          	DelayMs(2000);
   1217          	
   1218          	start_timer = 400;		// 4 sec
   1219          	WDTCTL = WDT_ADLY_16;                   // Interval timer	/* for 50 ms */
   1220          // *****************************************************************
   1221          // ******************   M A I N   L O O P  *************************
   1222          // *****************************************************************
   1223          	while(1) {
   1224          		
   1225          		//-------------------------------------------------------------------------------
   1226          		//
   1227          		// ******** Обработчики событий ********
   1228          		//
   1229          		//-------------------------------------------------------------------------------
   1230          		
   1231          //-------------------------------------------------------------------------------
   1232          // TimerA0 Event		
   1233          //-------------------------------------------------------------------------------
   1234          		if (fTimerA_On) {				// Закончен период ожидания измерительных импульсов
   1235          			fTimerA_On = 0;
   1236          			
   1237          			BCSCTL1 = CALBC1_16MHZ; 	// Используем частоту 16 MГц
   1238          			DCOCTL =  CALDCO_16MHZ;
   1239          			//
   1240          			TA1CCR0  = 0xFFFF - 1;   	// ~ Compensation of frequence increase
   1241          			//
   1242          			Timer_A0_Off();				
   1243          			
   1244          			ADC_MeasureStart();
   1245          		
   1246          			timerA1_blank = 4;
   1247          		}
   1248          
   1249          //-------------------------------------------------------------------------------
   1250          // fTimer50msOn Event				
   1251          //-------------------------------------------------------------------------------
   1252          		if (fTimer50msOn) {		// Получен следующий 50мс интервал
   1253          			fTimer50msOn = 0;
   1254          			//
   1255          			Timer50msCounter = 0;
   1256          		}
   1257          		
   1258          //-------------------------------------------------------------------------------
   1259          // TimerA1 Event (SysTick) 10 ms
   1260          //-------------------------------------------------------------------------------
   1261          		if (fTimerA1_On) {				// Получен следующий интервал timer
   1262          			fTimerA1_On = 0;
   1263          			
   1264          			if (start_timer) {
   1265          				start_timer--;
   1266          				if (start_timer == 0) {
   1267          					CalibrFault.byte = CONFIG->calibr_fault;
   1268          
   1269          					flash_period_timer = 500;	// Need flash after 5 sec
   1270          					strob_pulse_timer = 0;
   1271          				}
   1272          			}
   1273          			
   1274          			//TEST2_OUT ^= TEST2_BIT;
   1275          			//
   1276          			if (timerKeyDown) {
   1277          				timerKeyDown++;
   1278          				if (timerKeyDown > 200 ) {			// > 2 sec - Start Calibration
   1279          					// CALIBRATION Start
   1280          					//
   1281          					JP1_Define();			// Define JP1 on BVS state
   1282          					if (jp1_state == 0) {
   1283          						// JP1 is Open 
   1284          						cfg_reg.fDrift = 1;
   1285          					}else{
   1286          						cfg_reg.fDrift = 0;
   1287          					}
   1288          					//
   1289          					// Calibration mode init 
   1290          					DeviceMode = MODE_CALIBR;
   1291          					
   1292          					// Calibration from most amp to small
   1293          					FIRE_SET();				// Set Fire output key
   1294          					FAULT_CLR();			// Clear Fault Signal
   1295          					BREAK_DISABLE();		// Enable of transmitter
   1296          					
   1297          					DeviceFault.fStrobNone = 0;
   1298          					strob_pulse_timer = 0;
   1299          					//
   1300          					calibr_stage = 0;
   1301          					n_counter = 0;
   1302          					summa = 0;
   1303          					//
   1304          					amp_no = calibr_sequence[calibr_stage][0];
   1305          					gain = calibr_sequence[calibr_stage][1];
   1306          					reference = calibr_sequence[calibr_stage][2];
   1307          					//
   1308          					AMP_SetGain(gain);
   1309          					
   1310          					QualityFaultCounter = 0;
   1311          					DeviceFault.byte = 0;
   1312          					CalibrFault.byte = 0;
   1313          					fault_timer = 0;
   1314          					fault_phase = 0;
   1315          					
   1316          					RED_CLR();
   1317          					YEL_CLR();
   1318          					
   1319          					timerKeyDown = 0;
   1320          					
   1321          					flash_period_timer = 120;	// Flash after 1.2 sec
   1322          					light_timer = 7;			// Value - the power of LED light
   1323          				}
   1324          			}
   1325          			
   1326          			if (zero_timer) {
   1327          				zero_timer++;
   1328          			}
   1329          				
   1330          			if (fault_chain_timer)  {
   1331          				fault_chain_timer--;
   1332          				if (DeviceMode != MODE_FIRE) {
   1333          					if (fault_chain_timer == 0) {
   1334          						if (fault_sequence[fault_chain_ind] == 0) {
   1335          							fault_chain_ind = 0;
   1336          							DeviceMode = MODE_NORM;
   1337          						}else{
   1338          							DeviceMode = fault_sequence[fault_chain_ind++];
   1339          							fault_chain_timer = getTimerValue(fault_sequence[fault_chain_ind++]);
   1340          							//
   1341          							switch (DeviceMode) {
   1342          								case MODE_FIRE:
   1343          									FIRE_SET();
   1344          									//
   1345          									RED_SET();
   1346          									YEL_CLR();
   1347          									fault_chain_timer = 0;
   1348          									strob_pulse_timer = 0;
   1349          									zero_timer = 0;
   1350          									BREAK_DISABLE();		// Enable of transmitter
   1351          									DeviceFault.fSignal_Low = 0;
   1352          									break;
   1353          								case MODE_FAULT:
   1354          									BREAK_ENABLE();			// Disable of transmitter
   1355          									break;
   1356          								case MODE_NORM:
   1357          									strob_pulse_timer = 0;
   1358          									zero_timer = 0;
   1359          									DeviceFault.fSignal_Low = 0;
   1360          									BREAK_DISABLE();		// Enable of transmitter
   1361          							}
   1362          						}
   1363          					}
   1364          				}
   1365          			}
   1366          			
   1367          			if (timerMain) {
   1368          				timerMain--;
   1369          				if (timerMain == 0) {
   1370          					if (DeviceMode == MODE_TEST) {
   1371          						DeviceMode = MODE_NORM;
   1372          						RED_CLR();
   1373          						YEL_CLR();
   1374          						FIRE_CLR();
   1375          					}
   1376          				}
   1377          			}
   1378          			//
   1379          			// Setting signals in Fault Mode (LEDs and other pins)
   1380          			FaultSignalManager();
   1381          			//
   1382          			
   1383          			if (timerA1_blank) {
   1384          				timerA1_blank--;
   1385          			}else{
   1386          				// ---- LED Indication ----
   1387          				//
   1388          				if (light_timer) {
   1389          					light_timer--;
   1390          					//
   1391          					if ((DeviceMode == MODE_NORM) || (DeviceMode == MODE_PREFIRE) || (DeviceMode == MODE_PREPREFIRE)) {
   1392          						RED_SET();
   1393          						YEL_CLR();
   1394          					}else
   1395          					//
   1396          					if (DeviceMode == MODE_CALIBR) {
   1397          						RED_SET();
   1398          						YEL_SET();
   1399          					}
   1400          				}else{
   1401          					//
   1402          					if ((DeviceMode == MODE_NORM) || (DeviceMode == MODE_CALIBR) || (DeviceMode == MODE_PREFIRE) || (DeviceMode == MODE_PREPREFIRE)) {
   1403          						RED_CLR();
   1404          						YEL_CLR();
   1405          					}
   1406          				}
   1407          				//	
   1408          				if ((DeviceMode == MODE_FAULT) || (DeviceMode == MODE_TEST)) {
   1409          					//
   1410          					// LED management
   1411          					//
   1412          					if (light_sync >= 3) {
   1413          						light_sync = 0;
   1414          						led_sh = 0x80000000;
   1415          						//
   1416          						led_timer = 300;		// 3 sec period
   1417          					}
   1418          					
   1419          					if (led_timer) {
   1420          						led_timer--;
   1421          					}else{
   1422          						led_timer = 300;		// 3 sec period
   1423          						led_sh = 0x80000000;
   1424          						//
   1425          						light_sync = 0;
   1426          					}
   1427          					//
   1428          					if (++led_clk >= 4) {		// T = 30 ms
   1429          						led_clk = 0;
   1430          						//
   1431          						if (led_r & led_sh) {
   1432          							RED_SET();
   1433          							TEST2_SET();
   1434          						}else{
   1435          							RED_CLR();
   1436          							TEST2_CLR();
   1437          						}
   1438          						//
   1439          						if (led_y & led_sh) {
   1440          							YEL_SET(); 
   1441          						}else{
   1442          							YEL_CLR();
   1443          						}
   1444          						//
   1445          						if (DeviceMode == MODE_TEST) {
   1446          							YEL_SET(); 
   1447          						}
   1448          						//
   1449          						led_sh >>= 1;
   1450          					}
   1451          				}
   1452          			} // End indication
   1453          			//
   1454          			//
   1455          			// Strob pulse diagnostic 
   1456          			if ((strob_pulse_timer == 200) || (strob_pulse_timer == 1800)){
   1457          				STROB_IE_Enable();
   1458          			}
   1459          			if (++strob_pulse_timer >= 2000) {	// 20 sec
   1460          				strob_pulse_timer = 0;
   1461          				if (DeviceFault.fStrobNone == 0) {
   1462          					if (CalibrFault.byte == 0) {
   1463          						DeviceFault.fStrobNone = 1;
   1464          						SetFaultMode();
   1465          					}
   1466          				}
   1467          			}
   1468          			//
   1469          			if (flash_period_timer) {
   1470          				flash_period_timer--;
   1471          				if (flash_period_timer == 0) {
   1472          					flash_period_timer = 120;	// Flash after 1.2 sec
   1473          					if ((DeviceMode == MODE_NORM) || (DeviceMode == MODE_PREPREFIRE)){
   1474          						light_timer = 1;				// Value - the light power
   1475          					}else
   1476          					if (DeviceMode == MODE_CALIBR) {
   1477          						light_timer = 7;				// Value - the light power
   1478          					}
   1479          				}
   1480          			}
   1481          			sleep();	
   1482          		} // if (fTimerA1_On 10 ms)
   1483          		
   1484          //-------------------------------------------------------------------------------
   1485          // End of samples of ADC Event
   1486          		if (fEndOfSamples) {	// End of samples of ADC Event
   1487          			fEndOfSamples = 0;
   1488          
   1489          			AMP_PWR_OFF();						// AMP Power Supply Disable			
   1490          			
   1491          			//VREF_Off();						// Vref Disable
   1492          			ADC10CTL0 &= ~ENC;
   1493          			while (ADC10CTL1 & BUSY);           // Wait if ADC10 core is active 
   1494          			ADC10CTL0 &= ~REFON;
   1495          			
   1496          
   1497          			//AMP_Off_Timer = CONFIG->timer_calibr - CONFIG->timer_calibr / 4 + 1;	//CONFIG->timer_calibr - CONFIG->timer_calibr / 4 + 1;
   1498          			//
   1499          			BCSCTL1 = CALBC1_8MHZ; 					// Используем частоту 1 MГц
   1500          			DCOCTL =  CALDCO_8MHZ;
   1501          			//
   1502          			TA1CCR0  = 0xFFFF - 1;   			// ~ Compensation of frequence increase
   1503          			//
   1504          			DelayUs(1);
   1505          			//
   1506          			if (fSendingGraph) {
   1507          				loc_buf[0] = Q_SEND_GRAPH1;
   1508          				loc_buf[1] = SIGNAL_ARRAY_LEN * 2;
   1509          				SoftUART_TxString(loc_buf, 2);
   1510          				//
   1511          				SoftUART_TxString((u8*)&signal_array[0], SIGNAL_ARRAY_LEN * 2);
   1512          			}
   1513          			//
   1514          			//
   1515          			if (start_timer || CalibrFault.byte || DeviceFault.fFaultDrift) {
   1516          				goto label_light;
   1517          			}
   1518          			
   1519          			STROB_IE_Enable();
   1520          			strob_pulse_timer = 0;
   1521          		
   1522          			//TEST2_SET();
   1523          			quality = SignalAnalysis();
   1524          			//TEST2_CLR();
   1525          			//
   1526          			BCSCTL1 = CALBC1_1MHZ; 					// Используем частоту 1 MГц
   1527          			DCOCTL =  CALDCO_1MHZ;
   1528          			TA1CCR0  = 1 * SYS_TICK_TIME - 1;   	// Period T(us) * F(MHz)
   1529          			DelayUs(1);
   1530          			//
   1531          			//	
   1532          			if (DeviceMode == MODE_CALIBR) {
   1533          				//
   1534          				// -------- CALIBRATION ---------
   1535          				//
   1536          				n_counter++;
   1537          				summa += delta;
   1538          				
   1539          				if (n_counter >= 2) {
   1540          					delta = summa / n_counter;
   1541          					n_counter = 0;
   1542          					summa = 0;
   1543          					//
   1544          					s_array[calibr_stage] = delta;
   1545          					q_array[calibr_stage] = quality;
   1546          					//
   1547          					if (++calibr_stage >= CALIBR_STAGES) {
   1548          						// End of calibration
   1549          						//
   1550          						CalibrationResultAnalise();
   1551          						if (CalibrFault.byte) {
   1552          							DeviceMode = MODE_FAULT;
   1553          						}
   1554          						//
   1555          						goto label_light;
   1556          					}
   1557          					//
   1558          					//	Set new	 Amp_No	Gain  Reference
   1559          					amp_no = calibr_sequence[calibr_stage][0];
   1560          					gain = calibr_sequence[calibr_stage][1];
   1561          					reference = calibr_sequence[calibr_stage][2];
   1562          					//
   1563          					AMP_SetGain(gain);
   1564          					//
   1565          				}
   1566          			}else
   1567          			//
   1568          			// -------- NORM behavior -------------
   1569          			//
   1570          			if (quality == 2) {	
   1571          				// Very high signal
   1572          				if (++QualityFaultCounter > 10) {
   1573          					CalibrFault.fCalibr_Hi = 1;
   1574          					QualityFaultCounter = 0;
   1575          				}
   1576          				//
   1577          				goto label_light;
   1578          			}else{
   1579          				QualityFaultCounter = 0;
   1580          			}
   1581          			
   1582          			if (((DeviceMode == MODE_NORM) || (DeviceMode == MODE_PREPREFIRE)) && fault_chain_timer) {
   1583          				// Обрабатывается полное перекрытие
   1584          				if (delta > getZeroLevel()) {
   1585          					fault_chain_timer = 0;
   1586          					fault_chain_ind = 0;
   1587          					DeviceFault.fSignal_Low = 0;
   1588          				}
   1589          			}
   1590          			
   1591          			if (((DeviceMode == MODE_NORM) || (DeviceMode == MODE_PREPREFIRE)) && (fault_chain_timer == 0)) {
   1592          				if ((delta >= CONFIG->limit_fire) && (delta <= SYGNAL_MAX_VALUE)) {
   1593          					// Reset all counters
   1594          					fire_level_counter = 0;
   1595          					hi_signal_counter = 0;
   1596          					zero_timer = 0;
   1597          				}
   1598          								
   1599          				if (delta <= getZeroLevel()) {
   1600          					if (zero_timer == 0) {	
   1601          						zero_timer = 1;
   1602          					}else
   1603          					if (zero_timer > 1000) {	// 10 sec
   1604          						// Полное перекрытие 
   1605          						fault_chain_ind = 0;
   1606          						DeviceMode = fault_sequence[fault_chain_ind++];
   1607          						fault_chain_timer = getTimerValue(fault_sequence[fault_chain_ind++]);
   1608          						DeviceFault.fSignal_Low = 1;
   1609          						zero_timer = 0;
   1610          						//
   1611          						BREAK_ENABLE();			// Disable of transmitter
   1612          						//
   1613          					}
   1614          				}else{
   1615          					zero_timer = 0;
   1616          					//
   1617          					if (delta < CONFIG->limit_prefire) {
   1618          						DeviceMode = MODE_PREPREFIRE;
   1619          					}
   1620          					
   1621          					if (DeviceMode == MODE_PREPREFIRE) {
   1622          						if (delta > CONFIG->limit_prefire) {
   1623          							DeviceMode = MODE_NORM;
   1624          						}
   1625          					}
   1626          					
   1627          					if (delta < CONFIG->limit_fire) {
   1628          						fire_level_counter = 5;
   1629          						DeviceMode = MODE_PREFIRE;
   1630          					}
   1631          					
   1632          					// Hi signal management
   1633          					if (delta > SYGNAL_MAX_VALUE) {
   1634          						// Very high signal
   1635          						hi_signal_counter++;
   1636          						if (hi_signal_counter >= 10) {
   1637          							//DeviceMode = MODE_FAULT;
   1638          							CalibrFault.fCalibr_Hi = 1;
   1639          							hi_signal_counter = 0;
   1640          						}
   1641          					}
   1642          				}
   1643          			}else
   1644          			if (DeviceMode == MODE_PREFIRE) {
   1645          				//
   1646          				// Защита от плавного изменения уровня сигнала
   1647          				if ((delta == 0) && (delta_last > 0)) {
   1648          					fire_level_counter = 10;
   1649          				}
   1650          				//	
   1651          				if ((delta <= getZeroLevel()) && (fire_level_counter == 5)) {
   1652          					if (zero_timer == 0) {	
   1653          						zero_timer = 1;
   1654          						DeviceMode = MODE_NORM;
   1655          					}
   1656          				}else
   1657          				if (delta < CONFIG->limit_fire) {
   1658          					if (--fire_level_counter == 0) {
   1659          						DeviceMode = MODE_FIRE;
   1660          						FIRE_SET();
   1661          						RED_SET();
   1662          						YEL_CLR();
   1663          						DeviceFault.byte = 0;
   1664          					}
   1665          				}else{
   1666          					DeviceMode = MODE_NORM;
   1667          				}
   1668          				//
   1669          				delta_last = delta;
   1670          			}
   1671          			//
   1672          			if (CONFIG->config_reg.fDrift) {
   1673          				// if JP1 state is open
   1674          				if ((DeviceMode == MODE_NORM) && delta) {
   1675          					// Long Term Drift Adjustment
   1676          					DriftSumma += delta;
   1677          					DriftCounter++;
   1678          					if (DriftCounter >= DRIFT_SAMPLES_MAX) {
   1679          						DriftLevel = DriftSumma / DriftCounter;
   1680          						//
   1681          						if ((u16)DriftLevel < CONFIG->limit_drift) {
   1682          							//
   1683          							DeviceFault.fFaultDrift = 1;
   1684          							SetFaultMode();
   1685          							//
   1686          							SetLevels(CONFIG->limit_drift);
   1687          						}else{
   1688          							SetLevels((u16)DriftLevel);
   1689          						}
   1690          						//	
   1691          						ClearDriftVar();
   1692          						//
   1693          					}
   1694          				}
   1695          			}
   1696          			//			
   1697          			//
   1698          label_light:			
   1699          			//
   1700          			BCSCTL1 = CALBC1_1MHZ; 					// Используем частоту 1 MГц
   1701          			DCOCTL =  CALDCO_1MHZ;
   1702          			TA1CCR0  = 1 * SYS_TICK_TIME - 1;   	// Period T(us) * F(MHz)
   1703          			//
   1704          			DelayUs(1);
   1705          			//
   1706          			if (fSendingGraph) {
   1707          				//
   1708          				BCSCTL1 = CALBC1_8MHZ; 					// Используем частоту 8 MГц
   1709          				DCOCTL =  CALDCO_8MHZ;
   1710          				TA1CCR0  = 0xFFFF - 1;   				// ~ Compensation of frequence increase
   1711          				//
   1712          				//
   1713          				for (i = 0; i < SIGNAL_ARRAY_LEN; i++) {
   1714          					signal_array[i] += 350;
   1715          				}
   1716          				
   1717          				loc_buf[0] = Q_SEND_GRAPH2;
   1718          				loc_buf[1] = SIGNAL_ARRAY_LEN * 2;
   1719          				SoftUART_TxString(loc_buf, 2);
   1720          				//
   1721          				SoftUART_TxString((u8*)&signal_array[0], SIGNAL_ARRAY_LEN * 2);
   1722          				
   1723          				SoftUART_TxString((u8*)&delta, 2);
   1724          				
   1725          				fSendingGraph = 0;
   1726          				//
   1727          				BCSCTL1 = CALBC1_1MHZ; 					// Используем частоту 1 MГц
   1728          				DCOCTL =  CALDCO_1MHZ;
   1729          				TA1CCR0  = 1 * SYS_TICK_TIME - 1;   	// Period T(us) * F(MHz)
   1730          				//
   1731          			}
   1732          			//
   1733          			//
   1734          			// Indication
   1735          			//
   1736          			if (DeviceMode == MODE_NORM) {
   1737          				light_timer = 1;				// Value - the light power
   1738          				flash_period_timer = 120;		// Flash after 1.2 sec
   1739          			}
   1740          			//
   1741          			if ((DeviceMode == MODE_PREFIRE) || (DeviceMode == MODE_PREPREFIRE)) {
   1742          				light_timer = 4;				// Value - the light power
   1743          				flash_period_timer = 120;		// Flash after 1.2 sec
   1744          			}
   1745          			//
   1746          			if (DeviceMode == MODE_CALIBR) {
   1747          				light_timer = 7;				// Value - the light power
   1748          				flash_period_timer = 120;		// Flash after 1.2 sec
   1749          			}
   1750          			//
   1751          			if (DeviceMode == MODE_TEST) {
   1752          				// Indication sygnal level
   1753          				LedTestValueManager();			
   1754          				//
   1755          			}
   1756          			//
   1757          			light_sync++;
   1758          			led_timer = 400;	//4 sec
   1759          			
   1760          			STROB_IE_Enable();
   1761          		}
   1762          		
   1763          //-------------------------------------------------------------------------------
   1764          // Strobe StartPulse Event		
   1765          		if (fStartPulse) {			// Start pulse was received
   1766          			fStartPulse = 0;
   1767          			//
   1768          			AMP_PWR_ON();						// AMP Power Supply Enable
   1769          			// Vref Enable
   1770          			if (DeviceMode == MODE_CALIBR) {
   1771          				ADC_MeasureInit(amp_no, reference);
   1772          			}else{
   1773          				ADC_MeasureInit(CONFIG->AMP_No, reference);
   1774          			}
   1775          			
   1776          			//TEST2_SET();
   1777          			
   1778          			_BIC_SR(GIE);    			// Запрещаем прерывания
   1779          //			Timer_A0_SetDelay(2250);
   1780          			Timer_A0_SetDelay(700);
   1781          			_BIS_SR(GIE);    			// Разрешаем прерывания
   1782          			//
   1783          			BCSCTL1 = CALBC1_8MHZ; 		// Используем частоту 8 MГц
   1784          			DCOCTL =  CALDCO_8MHZ;
   1785          			//
   1786          			TA1CCR0  = 0xFFFF - 1;   	// ~ Compensation of frequence increase
   1787          			//
   1788          			// For define the presence of strob pulses
   1789          			strob_pulse_timer = 0;
   1790          			DeviceFault.fStrobNone = 0;
   1791          			//
   1792          			fault_phase = 0;
   1793          			fault_timer = 0;
   1794          		}
   1795          		
   1796          
   1797          //-------------------------------------------------------------------------------
   1798          // KEY DOWN event		
   1799          		if (fButtonDownOn) {									// Нажата кнопка
   1800          			fButtonDownOn = 0;
   1801          			//...
   1802          			timerKeyDown = 1;
   1803          			//
   1804          		} // if (fButtonDownOn)
   1805          		
   1806          //-------------------------------------------------------------------------------
   1807          // KEY UP event
   1808          		if (fButtonUpOn) {			// Отжата кнопка
   1809          			fButtonUpOn = 0;
   1810          
   1811          			if ((timerKeyDown > 4) && (timerKeyDown < 150))  {	// < 1.5 sec
   1812          				// The short pressure on the button
   1813          				if ((DeviceMode == MODE_NORM) || (DeviceMode == MODE_PREFIRE) || (DeviceMode == MODE_PREPREFIRE)) {
   1814          					DeviceMode = MODE_TEST;
   1815          					DeviceFault.byte = 0;	// Reset all faults
   1816          					FIRE_SET();				// Set fire mode current consumption
   1817          					RED_CLR();
   1818          					YEL_SET();
   1819          					timerMain = 12000;		// 120 sec
   1820          					led_sh = 0;
   1821          					led_timer = 0;			// Устраняем задержку оптической индикации
   1822          					led_clk = 0xFF;
   1823          				}else
   1824          				//	
   1825          				if (DeviceMode == MODE_TEST) {
   1826          					DeviceMode = MODE_NORM;
   1827          					DeviceFault.byte = 0;	// Reset all faults
   1828          					//led_timer = 0;
   1829          					RED_CLR();
   1830          					YEL_CLR();
   1831          					FIRE_CLR();
   1832          				}else
   1833          				//
   1834          				if (DeviceMode == MODE_FIRE) {
   1835          					DeviceMode = MODE_NORM;
   1836          					DeviceFault.byte = 0;	// Reset all faults
   1837          					RED_CLR();
   1838          					YEL_CLR();
   1839          					FIRE_CLR();				// Disable Fire Mode consumption
   1840          					led_r = 0;
   1841          					led_y = 0;
   1842          				}
   1843          			}
   1844          			//
   1845          			timerKeyDown = 0;
   1846          		} // if (fButtonUpOn) {
   1847          
   1848          		
   1849          //-------------------------------------------------------------------------------
   1850          // Soft UART Rx Hundler
   1851          		if (fRxLineDownOn) {
   1852          			uart_rx_ind = 0;
   1853          			//
   1854          label_rx_continue:
   1855          			fRxLineDownOn = 0;
   1856          			//
   1857          			DelayUs_8MHz(25);		// Delay to center of pulse
   1858          			//
   1859          			//TEST2_SET();
   1860          			//TEST2_CLR();
   1861          			//
   1862          			if ((INTER_BIT & INTER_IN) == 0) {
   1863          				SoftUART_SetReceiveByte();
   1864          				
   1865          			}else{
   1866          				//
   1867          				BCSCTL1 = CALBC1_1MHZ; 					// Используем частоту 1 MГц
   1868          				DCOCTL =  CALDCO_1MHZ;
   1869          				//
   1870          				TA1CCR0  = 1 * SYS_TICK_TIME - 1;   	// Period T(us) * F(MHz)
   1871          				//
   1872          				continue;		// False pulse
   1873          			}
   1874          			sh = 0x01;
   1875          			byte = 0;
   1876          			while (sh) {
   1877          				if (fTimerA_On) {
   1878          					fTimerA_On = 0;
   1879          					//
   1880          					//TEST2_SET();
   1881          					//TEST2_CLR();
   1882          					//
   1883          					if (INTER_BIT & INTER_IN) {
   1884          						byte |= sh;
   1885          					}
   1886          					sh <<= 1;
   1887          				}
   1888          			}
   1889          			// Receive byte
   1890          			SoftUART_ResetReceiveByte();
   1891          			//
   1892          			if (uart_rx_ind == 0) {
   1893          				// Begin of packet
   1894          				len = packet_len_table[byte];
   1895          				if (len > UART_BUF_LEN) {
   1896          					len = UART_BUF_LEN;
   1897          				}
   1898          			}
   1899          				
   1900          			*(uart_rx_buf+uart_rx_ind++) = byte;
   1901          			if (uart_rx_ind >= len) {
   1902          				// Parse of packet
   1903          				//...
   1904          				SoftUART_RxParse();
   1905          				INTER_IFG &= ~INTER_BIT;    				// Обнуляем флаг прерывания
   1906          				fRxLineDownOn = 0;
   1907          			}else{
   1908          				//			
   1909          				uart_timer = 4;								// 200 ms timeout to next byte
   1910          				while (1) {
   1911          					//__bis_SR_register(LPM3_bits + GIE);     // Enter LPM3
   1912          					//
   1913          					while ((fRxLineDownOn || fTimer50msOn) == 0) {}
   1914          					//
   1915          					if (fRxLineDownOn) {
   1916          						goto label_rx_continue;
   1917          					}
   1918          					if (fTimer50msOn) {						// Получен следующий 50мс интервал
   1919          						fTimer50msOn = 0;
   1920          						//
   1921          						if (uart_timer) {
   1922          							uart_timer--;
   1923          						}else{
   1924          							// End of Rx timeout
   1925          							//...
   1926          							INTER_IFG &= ~INTER_BIT;    	// Обнуляем флаг прерывания
   1927          							fRxLineDownOn = 0;
   1928          							break;
   1929          						}
   1930          					}
   1931          				}
   1932          			}
   1933          			//
   1934          			//
   1935          			BCSCTL1 = CALBC1_1MHZ; 					// Используем частоту 1 MГц
   1936          			DCOCTL =  CALDCO_1MHZ;
   1937          			//
   1938          			TA1CCR0  = 1 * SYS_TICK_TIME - 1;   	// Period T(us) * F(MHz)
   1939          			//
   1940          			//
   1941          		} // Soft UART Rx Hundler
   1942          	} // while(1)
   1943          }
   1944          
   1945          
   1946          
   1947          
   1948          //--------------------------------------------------------------------------------
   1949          // Function		: __interrupt void watchdog_timer (void)
   1950          // Parameters	: None
   1951          // Return		: None
   1952          // Description	: WDT Interrupt routine
   1953          //--------------------------------------------------------------------------------
   1954          #pragma vector=WDT_VECTOR
   1955          __interrupt void watchdog_timer (void) {
   1956          	
   1957          	if (fTimer50msOn) {
   1958          		if (++Timer50msCounter == 0) {		// > ~ 12sec
   1959          			WDTCTL = WDTCTL;				// Hardware RESET
   1960          		}
   1961          	}
   1962          	fTimer50msOn = 1;
   1963          	
   1964          	__bic_SR_register_on_exit(LPM3_bits);                   // Clear LPM3 bits from 0(SR)
   1965          }
   1966          
   1967          
   1968          
   1969          //--------------------------------------------------------------------------------
   1970          // Function		: __interrupt void CCR0_ISR(void)
   1971          // Parameters	: None
   1972          // Return		: None
   1973          // Description	: TIMER0 Interrupt routine
   1974          //--------------------------------------------------------------------------------
   1975          #pragma vector = TIMER0_A0_VECTOR
   1976          __interrupt void CCR0_ISR(void) {
   1977          
   1978          	fTimerA_On = 1;
   1979          	
   1980          } // CCR0_ISR
   1981          
   1982          
   1983          
   1984          //--------------------------------------------------------------------------------
   1985          // Function		: __interrupt void Timer_A1_ISR (void)
   1986          // Parameters	: None
   1987          // Return		: None
   1988          // Description	: TIMER1 Interrupt routine
   1989          //--------------------------------------------------------------------------------
   1990          #pragma vector=TIMER1_A0_VECTOR
   1991          __interrupt void Timer_A1_ISR (void)  {
   1992          	
   1993          	fTimerA1_On = 1;
   1994          	__bic_SR_register_on_exit(LPM3_bits);                   // Clear LPM3 bits from 0(SR)
   1995          } 
   1996          
   1997          
   1998          
   1999          //--------------------------------------------------------------------------------
   2000          // Function		: void Led_Flash(u16 duration)
   2001          // Parameters	: duration - duration Red LED flash in ms
   2002          // Return		: None
   2003          // Description	: Flashing red LED
   2004          //--------------------------------------------------------------------------------
   2005          void Led_Flash(u16 duration) {
   2006          	RED_SET();
   2007          	DelayMs(duration);
   2008          	RED_CLR();
   2009          }
   2010          
   2011          
   2012          
   2013          
   2014          
   2015          //--------------------------------------------------------------------------------
   2016          // Function		: u16 GetVCC(u8 boost_stop)
   2017          // Parameters	: boost_stop = 1 - if need call BoostStop() after measure
   2018          // Return		: Value in 10mV (for example 250 = 2.50V)
   2019          // Description	: Measurement the voltage VCC
   2020          //--------------------------------------------------------------------------------
   2021          u16 GetVCC(u8 boost_stop) {
   2022          	u16 res;	
   2023          	ADC_Measure(ADC_CH_VCC, 0, VCC_DATA_LEN);
   2024          	//~~~
   2025          	VREF_Off();
   2026          	//
   2027          	//	
   2028          	res = AverageData(adc_data1, VCC_DATA_LEN);
   2029          	res = res * 64 / 218 + 2;						//~~res = ((u32)res * 301) / 1024 & Compensation dV(R38)=20mV (max=302)
   2030          	return (res);			
   2031          }
   2032          
   2033          
   2034          
   2035          
   2036          //--------------------------------------------------------------------------------
   2037          // Function		: void VREF_On(void)
   2038          // Parameters	: None 
   2039          // Return		: None
   2040          // Description	: Enable VREF
   2041          //--------------------------------------------------------------------------------
   2042          void VREF_On(void) {
   2043          
   2044          	ADC10CTL0 = REFOUT + REFON + SREF_1 + MSC + ADC10ON;
   2045          	ADC10AE0 |= 0x10;                         // P1.4 ADC option select (VRef Out)
   2046          
   2047          }
   2048          
   2049          
   2050          
   2051          //--------------------------------------------------------------------------------
   2052          // Function		: void VREF_Off(void)
   2053          // Parameters	: None
   2054          // Return		: None
   2055          // Description	: Disable VREF
   2056          //--------------------------------------------------------------------------------
   2057          void VREF_Off(void) {
   2058          
   2059          	ADC10CTL0 = 0;							// Disable ADC & +VREF
   2060          	ADC10CTL0 = 0;							//
   2061          }
   2062          
   2063          
   2064          
   2065          //--------------------------------------------------------------------------------
   2066          // Function		: void ADC10_ISR(void)
   2067          // Parameters	: None
   2068          // Return		: None
   2069          // Description	: ADC10 interrupt service routine
   2070          //--------------------------------------------------------------------------------
   2071          #pragma vector=ADC10_VECTOR
   2072          __interrupt void ADC10_ISR(void) {
   2073          
   2074          	//ADC10AE0 &= ~0x0F;                      // Save only VRef Out
   2075          	
   2076          	adc_process = 0;
   2077          	
   2078          	fEndOfSamples = 1;
   2079          //	AMP_PWR_OFF();
   2080          	
   2081          	//__bic_SR_register_on_exit(CPUOFF);      // Clear CPUOFF bit from 0(SR)
   2082          	
   2083          }
   2084          
   2085          
   2086          
   2087          //--------------------------------------------------------------------------------
   2088          // Function		: u16 AverageData(u16 * data_ptr, u8 len)
   2089          // Parameters	: data_ptr - data array pointer, len - length of data array
   2090          // Return		: Average value of data
   2091          // Description	: Fuction calculate the average value of data array
   2092          //--------------------------------------------------------------------------------
   2093          u16 AverageData(u16 * data_ptr, u8 len) {
   2094          	u16 summa = 0;
   2095          	u8  i = len;
   2096          	while (i--) {
   2097          		summa += *data_ptr++;
   2098          	}
   2099          	//
   2100          	return (summa/len);
   2101          }
   2102          
   2103          
   2104          //--------------------------------------------------------------------------------
   2105          // Function		: void DeviceDiagnostics(void)
   2106          // Parameters	: None
   2107          // Return		: None
   2108          // Description	: Procedure of the diagnostics device
   2109          //--------------------------------------------------------------------------------
   2110          void DeviceDiagnostics(void) {
   2111          	//
   2112          	DelayMs(100);
   2113          	//
   2114          	//
   2115          		
   2116          #if (CRC_ENABLE == 1)
   2117          	// Check CS of Memory
   2118          	DeviceFault.fFaultCRC = 0;
   2119          	if (GetPropertiesCS() != CONFIG->CS) {
   2120          		DeviceFault.fFaultCRC = 1;
   2121          	}
   2122          #endif
   2123          }
   2124          
   2125          //--------------------------------------------------------------------------------
   2126          // Function		: u16 ADC_Measure_Simple(u16 ch, u16* buf, u8 count)
   2127          // Parameters	: refout = 0 or REFOUT, vref = REF1_5V , count - кол-во измерений 
   2128          // Return		: None
   2129          // Description	: Measurement of the current temperature of MCU
   2130          //--------------------------------------------------------------------------------
   2131          #pragma optimize=none
   2132          u16 ADC_Measure_Simple(u16 ch, u16* buf, u8 count) {
   2133          	u16 res;
   2134          
   2135          	while(adc_process) {}
   2136          	
   2137          	BUT_IE &= ~BUT_BIT;
   2138          	BUT_REN &= ~BUT_BIT; 		// PULL disable
   2139          	
   2140          	ADC10CTL0 = SREF_0 + ADC10SHT_1 + MSC  + ADC10ON + ADC10IE;	// Sample&hold = 8 x ADC10CLKs
   2141          	
   2142          	DelayUs(50);	
   2143          	//
   2144          	ADC10CTL1 = ADC10SSEL_2 + ADC10DIV_7 + CONSEQ_2 + ch;	// ADC_BUT;     // 
   2145          	//
   2146          	DelayUs(200);							// Delay to allow Ref to settle
   2147          
   2148          	ADC10DTC1 = count;						// count of conversions
   2149          	ADC10AE0 = ADC_AE_BUT;                 // A3 & A7 ADC option select
   2150          	//
   2151          	ADC10SA = (u16) &buf[0];          		// Data buffer start
   2152          	
   2153          	fEndOfSamples = 0;
   2154          	ADC10CTL0 |= ENC + ADC10SC;             // Sampling and conversion start
   2155          		
   2156          	__bis_SR_register(CPUOFF + GIE);        // LPM0, ADC10_ISR will force exit
   2157          	
   2158          	while (fEndOfSamples == 0){};
   2159          	fEndOfSamples = 0;
   2160          
   2161          	res = AverageData(buf, count);	
   2162          
   2163          	ADC10AE0 = ADC_AE;          // A3 & A7 ADC option select
   2164          	
   2165          	BUT_IFG &= ~BUT_BIT;    	// Обнуляем флаг прерывания
   2166          	BUT_IE |= BUT_BIT;
   2167          	BUT_REN |= BUT_BIT; 		// PULL enable
   2168          	
   2169          	return res;
   2170          }
   2171          
   2172          
   2173          //--------------------------------------------------------------------------------
   2174          // Function		: void u8 JP1_Define(void)
   2175          // Parameters	: None
   2176          // Return		: 0 - JP1 Open, 1 - JP1 Close
   2177          // Description	: Definition of JP1 state
   2178          //--------------------------------------------------------------------------------
   2179          void JP1_Define(void) {
   2180          	u16 buf[4];
   2181          	u16 res;
   2182          	
   2183          	res = ADC_Measure_Simple(ADC_BUT, buf, 4);
   2184          	
   2185          	if (res > 600) return; 
   2186          	if (res > 100) {
   2187          		jp1_state = 0;		// JP1 is Open 
   2188          	}else{
   2189          		jp1_state = 1;		// JP1 is Close
   2190          	}	
   2191          	//
   2192          	return;	
   2193          }
   2194          
   2195          
   2196          // End of main.c

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   ADC10_ISR
      4   ADC_MeasureInit
        6   -> DelayUs
      0   ADC_MeasureStart
     10   ADC_Measure_Simple
       10   -> AverageData
       10   -> DelayUs
       10 ?Epilogue4
      0   ADC_SetParam
      2   AMP_Gain_Init
        0   -> AMP_SetGain
      2   AbsValue
      2   AverageData
        0 ?DivMod16u
      4   CCR0_ISR
     22   CalibrationResultAnalise
       22   -> AMP_SetGain
       22   -> SetLevelsFromCalibr
       22   -> SetLimitCompens
       22   -> StoragePropertyByte
       22   -> StoragePropertyWord
       14 ?Epilogue6
      2   ClearDriftVar
      2   DefineNewMode
      2   DeviceDiagnostics
        2   -> DelayMs
        2   -> GetPropertiesCS
      2   DeviceStart
        4   -> SavePropertyCS
        6   -> StoragePropertyWord
      2   FaultSignalManager
      2   GetVCC
        2   -> ADC_Measure
        2 ?DivMod16u
     10   JP1_Define
       10   -> ADC_Measure_Simple
      2   LedTestValueManager
      2   Led_Flash
        2   -> DelayMs
      0   SetFaultMode
      6   SetLevels
        8   -> SavePropertyCS
       10   -> StoragePropertyWord
        6   -> StoragePropertyWord
        6 ?DivMod16s
        6 ?DivMod16u
      6   SetLevelsFromCalibr
        8   -> SavePropertyCS
       10   -> StoragePropertyWord
        6   -> StoragePropertyWord
        6 ?DivMod16s
        6 ?DivMod16u
      2   SetLimitCompens
        2   -> SavePropertyCS
        4   -> StoragePropertyWord
     34   SignalAnalysis
       30 ?DivMod16s
       30 ?DivMod32s
       14 ?Epilogue6
       34 ?Mul16to32s
      2   TimerA1_DelayUs
      0   Timer_A0_Off
      2   Timer_A0_SetDelay
      4   Timer_A1_ISR
      0   Timer_A1_Init
      2   VLO_GetPeriod
      0   VLO_TimerCalibr
        2   -> SavePropertyCS
        4   -> StoragePropertyWord
      2   VREF_Off
      2   VREF_On
     10   fir_filter
       10 ?DivMod32s
       10 ?Epilogue4
       10 ?Mul16to32s
      2   getZeroLevel
        0 ?DivMod16u
     18   main
       18   -> ADC_Measure_Simple
       18   -> AMP_SetGain
       18   -> CalibrationResultAnalise
       18   -> DelayMs
       20   -> DelayMs
       18   -> DelayUs
       20   -> DelayUs
       18   -> DelayUs_8MHz
       18   -> FaultSignalManager
       18   -> GPIO_Init
       18   -> STROB_IE_Enable
       20   -> SavePropertyCS
       18   -> SignalAnalysis
       18   -> SoftUART_ResetReceiveByte
       18   -> SoftUART_RxParse
       18   -> SoftUART_SetReceiveByte
       18   -> SoftUART_TxString
       20   -> SoftUART_TxString
       18   -> StoragePropertyWord
       22   -> StoragePropertyWord
       18   -> VLO_TimerCalibr
       18 ?DivMod16s
       18 ?DivMod16u
       20 ?DivMod16u
       18 ?DivMod32u
      4   watchdog_timer


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       8  ??Subroutine42_0
       6  ??Subroutine43_0
      22  ??Subroutine5_0
      38  ?Subroutine0
      20  ?Subroutine10
      12  ?Subroutine11
      10  ?Subroutine12
      18  ?Subroutine13
      16  ?Subroutine14
       4  ?Subroutine15
      24  ?Subroutine16
      16  ?Subroutine17
      10  ?Subroutine18
      10  ?Subroutine19
       8  ?Subroutine2
      28  ?Subroutine20
      20  ?Subroutine21
      18  ?Subroutine22
      14  ?Subroutine23
      36  ?Subroutine24
      18  ?Subroutine25
       8  ?Subroutine26
      10  ?Subroutine27
      14  ?Subroutine28
      64  ?Subroutine3
      12  ?Subroutine30
      20  ?Subroutine32
      28  ?Subroutine33
       8  ?Subroutine34
      14  ?Subroutine35
       8  ?Subroutine36
      16  ?Subroutine37
       8  ?Subroutine38
       6  ?Subroutine39
      24  ?Subroutine4
       8  ?Subroutine40
       8  ?Subroutine41
       8  ?Subroutine5
       2  ?Subroutine6
      12  ?Subroutine7
      12  ?Subroutine8
      16  ?Subroutine9
       1  ADC10AE0
       2  ADC10CTL0
       2  ADC10CTL1
       1  ADC10DTC1
       2  ADC10SA
      10  ADC10_ISR
       2  ADC10_ISR::??INTVEC 10
      58  ADC_MeasureInit
       0  ADC_MeasureStart
     140  ADC_Measure_Simple
       0  ADC_SetParam
       8  AMP_Gain_Init
      14  AbsValue
      22  AverageData
       1  BCSCTL1
       1  BCSCTL3
       1  CALBC1_16MHZ
       1  CALBC1_1MHZ
       1  CALBC1_8MHZ
       1  CALDCO_16MHZ
       1  CALDCO_1MHZ
       1  CALDCO_8MHZ
       4  CCR0_ISR
       2  CCR0_ISR::??INTVEC 18
       2  CCR1_Value
       1  CalibrFault
     420  CalibrationResultAnalise
       4  ClearDriftVar
       1  DCOCTL
       4  DefineNewMode
      32  DeviceDiagnostics
       1  DeviceFault
       1  DeviceMode
      12  DeviceStart
       2  DriftCounter
       4  DriftLevel
       4  DriftSumma
      18  FIRCoef
     266  FaultSignalManager
       1  FireMeasCount
      74  GetVCC
       1  IE1
       1  IFG1
      36  JP1_Define
      88  LedTestValueManager
       8  Led_Flash
       1  P1OUT
       1  P2IE
       1  P2IFG
       1  P2IN
       1  P2OUT
       1  P2REN
       0  SetFaultMode
      22  SetLevels
      64  SetLevelsFromCalibr
      20  SetLimitCompens
     690  SignalAnalysis
       2  TA0CCR0
       2  TA0CCTL0
       2  TA0CCTL1
       2  TA0CTL
       2  TA0R
       2  TA1CCR0
       2  TA1CCTL0
       2  TA1CTL
       2  TA1R
       1  Timer50msCounter
      40  TimerA1_DelayUs
       0  Timer_A0_Off
      24  Timer_A0_SetDelay
       6  Timer_A1_ISR
       2  Timer_A1_ISR::??INTVEC 26
       0  Timer_A1_Init
      30  VLO_GetPeriod
       0  VLO_TimerCalibr
      10  VREF_Off
      14  VREF_On
       2  WDTCTL
      32  adc_data1
       1  adc_process
       1  amp_no
      18  calibr_sequence
       1  calibr_stage
       2  cfg_reg
       2  d1
       2  d2
       2  d3
       2  d4
       2  dark
       2  delta
       2  delta_last
       2  f
       1  fTimerA1_On
       1  fault_chain_ind
       2  fault_chain_timer
       1  fault_chamber_counter
       1  fault_phase
       8  fault_sequence
       2  fault_timer
     112  fir_filter
       2  flash_period_timer
       1  gain
      12  getZeroLevel
       2  hi_signal_counter
       1  jp1_state
       2  last_0_level
       2  last_level
       4  led_r
       4  led_sh
       4  led_y
       1  light_sync
       2  light_timer
    2322  main
       2  mainPeriodCounter
       6  q_array
       1  reference
      12  s_array
     200  signal_array
       2  start_timer
       1  strob_fault_phase
       2  strob_pulse_timer
       2  timerKeyDown
       2  timerLongPeriod
       2  timerMain
      18  watchdog_timer
       2  watchdog_timer::??INTVEC 20
      36  x
       2  zero_timer

 
 5 246 bytes in segment CODE
    45 bytes in segment DATA16_AN
    44 bytes in segment DATA16_C
   371 bytes in segment DATA16_Z
     8 bytes in segment INTVEC
     2 bytes in segment REGVAR_AN
 
 5 246 bytes of CODE     memory
    44 bytes of CONST    memory (+  8 bytes shared)
   371 bytes of DATA     memory (+ 45 bytes shared)
     0 bytes of REGISTER memory (+  2 bytes shared)

Errors: none
Warnings: 7
