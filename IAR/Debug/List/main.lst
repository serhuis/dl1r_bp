###############################################################################
#
# IAR C/C++ Compiler V6.40.1.950/W32 for MSP430           20/Mar/2017  17:56:05
# Copyright 1996-2015 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for Texas Instruments MSP430
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  regvar
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430
#    Source file   =  E:\_ARTON_PROJ\Arton-DL1-R\BP\soft\git\main.c
#    Command line  =  
#        E:\_ARTON_PROJ\Arton-DL1-R\BP\soft\git\main.c -lcN
#        E:\_ARTON_PROJ\Arton-DL1-R\BP\soft\git\IAR\Debug\List -o
#        E:\_ARTON_PROJ\Arton-DL1-R\BP\soft\git\IAR\Debug\Obj --debug
#        -D__MSP430G2433__ -e --double=32 --regvar_r4 --dlib_config "C:\Program
#        Files (x86)\IAR Systems\Embedded Workbench 7.3\430\lib\dlib\dl430fn.h"
#        -I ..\ -I .\ -Oh
#    List file     =  
#        E:\_ARTON_PROJ\Arton-DL1-R\BP\soft\git\IAR\Debug\List\main.lst
#    Object file   =  
#        E:\_ARTON_PROJ\Arton-DL1-R\BP\soft\git\IAR\Debug\Obj\main.r43
#
###############################################################################

E:\_ARTON_PROJ\Arton-DL1-R\BP\soft\git\main.c
      1          /**********************************************************************************
      2           *
      3           *      ASD-10QR MAIN routine
      4           * 
      5           **********************************************************************************
      6           * FileName:        main.c
      7           * Version:			1.00
      8           *
      9           * Processor:       MSP430G2xxx
     10           * Complier:        IAR Workbench for MSP430 v4.50 or higher
     11           *                  
     12           * Company:         ARTON
     13           *
     14           * Software License Agreement
     15           *
     16           * The software supplied herewith by ARTON Incorporated
     17           * (the "Company") for its devices is intended and
     18           * supplied to you, the Company's customer, for use solely and
     19           * exclusively on ARTON Inc products. The
     20           * software is owned by the Company and/or its Author, and is
     21           * protected under applicable copyright laws. All rights are reserved.
     22           * Any use in violation of the foregoing restrictions may subject the
     23           * user to criminal sanctions under applicable laws, as well as to
     24           * civil liability for the breach of the terms and conditions of this
     25           * license.
     26           *
     27           * THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES,
     28           * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
     29           * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
     30           * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
     31           * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
     32           * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
     33           *
     34           *
     35           * Author               Date      	Version	  		Comment
     36           *--------------------------------------------------------------------------------
     37           * Oleg Semeniuk	 16.01.2014    	1.00		Release for v1.00
     38           *
     39           *********************************************************************************/
     40          
     41          
     42          /*********************************************************************************/
     43          /*                                 INCLUDES                                      */
     44          /*********************************************************************************/
     45          
     46          
     47          #include <stdio.h>                    /* standard I/O .h-file                */
     48          #include <string.h>                   /* string and memory functions         */
     49          
     50          #include  "hardware.h"
     51          #include  "main.h"
     52          #include  "flash.h"
     53          #include  "type.h"
     54          #include  "delay.h"
     55          #include  "soft_uart.h"
     56          
     57          
     58          /*********************************************************************************/
     59          /*                                 VARIABLES                                     */
     60          /*********************************************************************************/
     61          
     62          __regvar __no_init tFlags 	f 	 @ __R4; 	// Set of state machine flags
     63          
     64          //
     65          u16		timerMain;					// Текущее значение главного таймера
     66          u16		timerLongPeriod;			// Таймер для режимa HUSH
     67          u16		mainPeriodCounter;			// Counter of main time period
     68          u16 	timerKeyDown;				// Для отслеживания нажатия на кнопку TEST
     69          u16		adc_data1[ADC_CH_DATA_LEN];	// Array for ADC samples
     70          
     71          u8 		DeviceMode; 				// Mode of device
     72          
     73          tFault	DeviceFault = {0};			// Current Faults flags
     74          tCalibrFault CalibrFault = {0};		// Calibration Faults flags
     75          u16 	dark;						// Level of dark signal
     76          u16 	delta;						// Current level signal
     77          
     78          u16 	delta_last = 0;				// Prev sygnal of delta
     79          u16		zero_timer = 0;				// Zero level signal timer
     80          
     81          u8		fault_chamber_counter = 0;	// Counter of series chamber fault
     82          u8  	FireMeasCount = 0;			// Количество замеров, превышающих порог Пожара
     83          
     84          // Variables for definition Long Term Drift
     85          u16  	DriftCounter = 0;
     86          u32 	DriftSumma = 0;
     87          u32 	DriftLevel;					// Current Long Term Drift Level
     88          	
     89          //u16 	FireLimit;					// Current Limit of Fire
     90          //u16 	PreFireLimit;				// Current Limit of PreFire
     91          	
     92          u16		CCR1_Value;					// CCR1 PWM duty cycle for sound generation
     93          u8 		Timer50msCounter = 0;		// Counter of 50ms ticks
     94          
     95          
     96          s16		signal_array[SIGNAL_ARRAY_LEN];
     97          
     98          //u8		AMP_Off_Timer = 0;
     99          
    100          
    101          volatile u32		led_r;
    102          volatile u32		led_y;
    103          volatile u32		led_sh = 0;
    104          
    105          u8 		fTimerA1_On = 0;
    106          
    107          
    108          #define CALIBR_STAGES		6
    109          u8 		calibr_stage;
    110          u16		s_array[CALIBR_STAGES];
    111          u8		q_array[CALIBR_STAGES];
    112          
    113          /* Old
    114          const u8 calibr_sequence[CALIBR_STAGES][3] = {
    115          //			 Amp_No	Gain  Reference
    116          			{  2,    3,     0 },
    117          			{  2,    3,     1 },
    118          			{  2,    2,     1 },
    119          			{  2,    1,     1 },
    120          			{  2,    0,     1 },
    121          			{  1,    0,     1 },
    122          			{  1,    0,     2 },
    123          };
    124          */
    125          
    126          const u8 calibr_sequence[CALIBR_STAGES][3] = {
    127          //			 Amp_No	Gain  Reference
    128          			{  1,    0,     2 },
    129          			//{  1,    0,     1 },
    130          			{  2,    0,     1 },
    131          			{  2,    1,     1 },
    132          			{  2,    2,     1 },
    133          			{  2,    3,     1 },
    134          			{  2,    3,     0 },
    135          };
    136          
    137          
    138          const u8 fault_sequence[4 * 2] = {MODE_FAULT, 10, MODE_NORM, 10, MODE_FIRE, 0, 0};	// 0 = ~~
    139          
    140          u8  fault_chain_ind = 0;	// 	
    141          u16 fault_chain_timer = 0;
    142          
    143          s8	gain;
    144          u8	amp_no;
    145          u8	reference;
    146          tCfgReg	cfg_reg;
    147          
    148          u8	jp1_state = 0;			// 0 - JP1 Open, 1 - JP1 Close
    149          
    150          u8	adc_process = 0;		// ADC low level semafore
    151          
    152          u16	light_timer = 0;		// For led lighting
    153          u8	light_sync = 0;			// For led lighting syncronisation
    154          
    155          u16	strob_pulse_timer = 0;	// Таймер ожидания электрической синхронизации
    156          u8	strob_fault_phase = 0;	// Фаза неисправности электрической синхронизации 0 - отключение БИ, 1 - включение БИ
    157          
    158          u16	hi_signal_counter  = 0;	// Very Hight signal counter
    159          
    160          u16	fault_timer = 0;		// Fault signal timer
    161          u8  fault_phase  = 0;		// Phase of  fault signal: 1 - break of BI , 0 - enable of  BI	
    162          
    163          u16 start_timer = 0;		// Start timer of device
    164          
    165          u16 flash_period_timer;		// Flast period timer
    166          
    167          
    168          
    169          
    170          
    171          /*********************************************************************************/
    172          /*                                FUNCTIONS                                      */
    173          /*********************************************************************************/
    174          // --- Declarations ---
    175          void ADC_MeasureInit(u8 input_no, u8 refer);
    176          u8   SignalAnalysis(void);
    177          void ADC_MeasureStart(void);
    178          void AMP_Calibration(void);
    179          
    180          u16  AverageData(u16 * data_ptr, u8 len);
    181          void SetRemoteAlarmMode(u8 sound);
    182          u8   RX_PacketParser(void);
    183          void ADC_Measure(u16 ch, u16 refout, u8 count);
    184          void ADC_Measure_TEMP(u16 ch, u16 refout, u8 count);
    185          
    186          void Timer_A1_Init(void);
    187          void Timer_A0_SetDelay(u16 period);
    188          void TimerA1_DelayUs(u16 time);
    189          void Timer_A0_Off(void);
    190          void JP1_Define(void);
    191          
    192          
    193          
    194          
    195          //--------------------------------------------------------------------------------
    196          // Function		: void VLO_TimerCalibr(void)
    197          // Parameters	: None
    198          // Return		: None
    199          // Description	: Calculation calibration value of VLO timer
    200          //--------------------------------------------------------------------------------
    201          void VLO_TimerCalibr(void) {
    202          	u16 clk;
    203          	
    204          	// Start timer 1MHz
    205          	TACTL = TASSEL_2 + MC_1 + ID_3;     	 	// SMCLK, up mode  / 8
    206          	//			
    207          	CCR0 = 62500 - 1;	                    // Period 0.5sec
    208          	CCTL1 = 0; 			                    // CCR1 reset/set
    209          	TACCTL0 = CCIE;							// Разрешаем прерывание таймера по достижению значения TACCCR0.
    210          	//
    211          	clk = 0;
    212          	while (1) {
    213          		if (fTimer50msOn) {
    214          			fTimer50msOn = 0;
    215          			clk++;
    216          		}
    217          		if (fTimerA_On) {
    218          			fTimerA_On = 0;
    219          			clk++;
    220          			break;
    221          		}
    222          	}
    223          	//
    224          	//SoundStop();							// Disable interrupts of timer
    225          	TACTL = 0;  
    226          	TACCTL0 = 0;				// Запрещаем прерывание таймера по достижению значения TACCCR0.
    227          	//
    228          	if (clk != CONFIG->timer_calibr) {
    229          		StoragePropertyWord(eeTIMER_CALIBR_OFFSET, clk * 2);
    230          		#if (CRC_ENABLE == 1)
    231          		SavePropertyCS();
    232          		#endif
    233          	}
    234          	//
    235          }
    236          
    237          
    238          //--------------------------------------------------------------------------------
    239          // Function		: void ClearDriftVar(void)
    240          // Parameters	: None
    241          // Return		: None
    242          // Description	: Clear Long Term Drift variables
    243          //--------------------------------------------------------------------------------
    244          void ClearDriftVar(void) {
    245          	DriftCounter = 0;
    246          	DriftSumma = 0;
    247          	DriftLevel = 0;
    248          }
    249          
    250          
    251          
    252          //--------------------------------------------------------------------------------
    253          // Function		: void SetLimitCompens(void)
    254          // Parameters	: fire_level - fire level in increment
    255          // Return		: None
    256          // Description	: Setting limit compensation level
    257          //--------------------------------------------------------------------------------
    258          void SetLimitCompens(void) {
    259          	u16 norm = CONFIG->limit_norm;
    260          	//
    261          	StoragePropertyWord(eeLIMIT_LONG_DRIFT_OFFSET, norm / 2);
    262          	//
    263          #if (CRC_ENABLE == 1)
    264          	SavePropertyCS();
    265          #endif
    266          	//
    267          	ClearDriftVar();
    268          	//
    269          }
    270          
    271          
    272          
    273          //--------------------------------------------------------------------------------
    274          // Function		: void SetLevels(u16 norm)
    275          // Parameters	: norm - norm sygnal level 
    276          // Return		: None
    277          // Description	: Calculation and setting levels depending on background signal
    278          //--------------------------------------------------------------------------------
    279          void SetLevels(u16 norm) {
    280          	u16 temp;
    281          	u8  d;	
    282          	StoragePropertyWord(eeLIMIT_NORM_OFFSET, norm);
    283          	//
    284          	d = norm * 28 / 100;
    285          	//
    286          	temp = norm - d;		//
    287          	StoragePropertyWord(eeLIMIT_FIRE_OFFSET, temp);
    288          	//
    289          	temp = norm - d * 3 / 4;		//
    290          	StoragePropertyWord(eeLIMIT_PREFIRE_OFFSET, temp);
    291          	
    292          	//
    293          #if (CRC_ENABLE == 1)
    294          	SavePropertyCS();
    295          #endif
    296          	//
    297          	ClearDriftVar();
    298          	//
    299          }
    300          
    301          
    302          
    303          //--------------------------------------------------------------------------------
    304          // Function		: void SetLevels(u16 norm)
    305          // Parameters	: norm - norm sygnal level, nonlinearity_corr - correction 
    306          //				  nonlinearity in case of Hi signal (0 - none, 1 - low correction,
    307          //				  2 - hi correction)
    308          // Return		: None
    309          // Description	: Calculation and setting levels depending on background signal
    310          //--------------------------------------------------------------------------------
    311          void SetLevelsFromCalibr(u16 norm, u8 nonlinearity_corr) {
    312          	u16 temp;
    313          	u8  d;	
    314          	StoragePropertyWord(eeLIMIT_NORM_OFFSET, norm);
    315          	//
    316          	switch (nonlinearity_corr) {
    317          		case 0:
    318          			d = norm * 29 / 100;
    319          			break;
    320          		case 1:
    321          			d = norm * 23 / 100;
    322          			break;
    323          		case 2:
    324          			d = norm * 18 / 100;
    325          			break;
    326          		default:
    327          			d = norm * 29 / 100;
    328          	}
    329          	//
    330          	temp = norm - d;		//
    331          	StoragePropertyWord(eeLIMIT_FIRE_OFFSET, temp);
    332          	//
    333          	temp = norm - d * 3 / 4;		//
    334          	StoragePropertyWord(eeLIMIT_PREFIRE_OFFSET, temp);
    335          	
    336          	//
    337          #if (CRC_ENABLE == 1)
    338          	SavePropertyCS();
    339          #endif
    340          	//
    341          	ClearDriftVar();
    342          	//
    343          }
    344          
    345          
    346          
    347          //--------------------------------------------------------------------------------
    348          // Function		: void DeviceStart(void)
    349          // Parameters	: None
    350          // Return		: None
    351          // Description	: Function executes initialization variable at start of device
    352          //--------------------------------------------------------------------------------
    353          void DeviceStart(void) {
    354          
    355          	DeviceFault.byte = 0;		// Reset faults flags
    356          	CalibrFault.byte = 0;		// Reset faults flags
    357          	//		
    358          	VLO_TimerCalibr();			// Calibration VLO Timer
    359          	//
    360          	ClearDriftVar();
    361          	
    362          }
    363          
    364          
    365          //--------------------------------------------------------------------------------
    366          // Function		: void DefineFireLimit(void)
    367          // Parameters	: None
    368          // Return		: None
    369          // Description	: Determination fire and prefire limits depending on long term drift
    370          //--------------------------------------------------------------------------------
    371          //#pragma optimize=none
    372          u16 getZeroLevel(void) {
    373          	u16 ret;
    374          	//
    375          	ret = CONFIG->limit_norm / 6;
    376          	return ret;
    377          }
    378          
    379          
    380          //--------------------------------------------------------------------------------
    381          // Function		: u16 getTimerValue(u16 period_sec)
    382          // Parameters	: time_sec : time in sec (0..655)
    383          // Return		: None
    384          // Description	: Getting time in system ticks
    385          //--------------------------------------------------------------------------------
    386          static u16 getTimerValue(u16 time_sec) {
    387          	u16 time = 100;
    388          	
    389          	if (time_sec > 655) return 0;
    390          	
    391          	time *= time_sec;	
    392          	
    393          	return time;
    394          
    395          }
    396          
    397          
    398          //--------------------------------------------------------------------------------
    399          // Function		: void VLO_TimerCalibr(void)
    400          // Parameters	: None
    401          // Return		: None
    402          // Description	: Calculation calibration value of VLO timer
    403          //--------------------------------------------------------------------------------
    404          u16 VLO_GetPeriod(void) {
    405          	
    406          	// Start timer 8MHz
    407          	TACTL = TASSEL_2 + MC_1;           	 	// SMCLK, up mode
    408          	//			
    409          	CCR0 =0xFFFF;                    		// Period 2.5mS
    410          	CCTL1 = 0; 			                    // CCR1 reset/set
    411          	TACCTL0 = 0;							// Разрешаем прерывание таймера по достижению значения TACCCR0.
    412          	//
    413          	while (fTimer50msOn == 0) {}
    414          	fTimer50msOn = 0;
    415          	//while (fTimer50msOn == 0) {}
    416          	
    417          	return TAR;
    418          	
    419          }
    420          
    421          
    422          //--------------------------------------------------------------------------------
    423          // Function		: void VLO_TimerCalibr(void)
    424          // Parameters	: None
    425          // Return		: None
    426          // Description	: Calculation calibration value of VLO timer
    427          //--------------------------------------------------------------------------------
    428          void AMP_Gain_Init(void) {
    429          	
    430          	AMP_SetGain(CONFIG->Gain);
    431          	
    432          }
    433          
    434          #define ADC_AMP1	INCH_1		/* First AMP out */
    435          #define ADC_AMP2	INCH_0		/* Second AMP out */
    436          #define ADC_BUT		INCH_2		/* Tact button */
    437          #define ADC_AE		0x13		/* Analog (Input) Enable Control Register Value + VREF+*/
    438          #define ADC_AE_BUT	0x17		/* Analog (Input) Enable Control Register Value + Tact sw + VREF+*/
    439          
    440          #define ADC_FLUCTATION			20
    441          #define SIGNAL_0_LEVEL			512
    442          
    443          #define CORREL_LEVEL			120		/* Threshold level to correlations of the start signal */
    444          
    445          
    446          
    447          //--------------------------------------------------------------------------------
    448          // Function		: ADC_Measure(u8 input_no, u8 refer)
    449          // Parameters	: input_no - number AMP output (= 1 or 2), refer - reference voltage (=0 - 1.5V, =1 - 2.5V, =2 - 3.3V)
    450          // Return		: None
    451          // Description	: Функция производит измерения по выбранному каналу ADC и помещает их в массив adc_data1
    452          //				   ~109 kS/s for 16 MHz 
    453          //--------------------------------------------------------------------------------
    454          void ADC_MeasureInit(u8 input_no, u8 refer) {
    455          	
    456          	ADC10CTL0 &= ~ENC;
    457          	while (ADC10CTL1 & BUSY);             	// Wait if ADC10 core is active 
    458          	//
    459          	switch ((Ref_Type)refer) {
    460          		case REF_1_5V:  
    461          			ADC10CTL0 = SREF_1 + ADC10SHT_1 + MSC + REFOUT + REFON + ADC10ON + ADC10IE;				// Sample&hold = 8 x ADC10CLKs
    462          			break;
    463          		case REF_2_5V:  
    464          			ADC10CTL0 = SREF_1 + ADC10SHT_1 + MSC + REFOUT + REFON + ADC10ON + ADC10IE + REF2_5V;	// Sample&hold = 8 x ADC10CLKs
    465          			break;
    466          		case REF_3_3V:  
    467          			ADC10CTL0 = SREF_0 + ADC10SHT_1 + MSC + ADC10ON + ADC10IE  + REFOUT + REFON + REF2_5V;	// Sample&hold = 8 x ADC10CLKs
    468          			break;
    469          	}
    470          	//
    471          	DelayUs(50);	
    472          	//
    473          	ADC10DTC1 = SIGNAL_ARRAY_LEN;	//ADC_SAMPLES_NUMBER;			// count of conversions
    474          	//
    475          	if (input_no == 1) {
    476          		ADC10CTL1 = ADC10SSEL_2 + ADC10DIV_7 + CONSEQ_2 + ADC_AMP1;     // MCLK + ADC10 Clock Divider Select 6 (DIV = 7),  Input 1
    477          	}else{
    478          		ADC10CTL1 = ADC10SSEL_2 + ADC10DIV_7 + CONSEQ_2 + ADC_AMP2;     // MCLK + ADC10 Clock Divider Select 6 (DIV = 7),  Input 2
    479          	}
    480          	
    481          	ADC10AE0 |= ADC_AE;                     // A0 & A1 ADC option select
    482          	//
    483          }
    484          
    485          
    486          //--------------------------------------------------------------------------------
    487          // Function		: ADC_Measure(u16 ch, u16 refout, u8 count)
    488          // Parameters	: ch - ADC channel, refout - 0 or REFOUT, count - кол-во измерений 
    489          // Return		: None
    490          // Description	: Функция производит измерения по выбранному каналу ADC и помещает их в массив adc_data1
    491          //--------------------------------------------------------------------------------
    492          void ADC_MeasureStart(void) {
    493          	__disable_interrupt();		// Disable interrupt
    494          	
    495          	adc_process = 1;
    496          	
    497          	//ADC10SA = (u16) &signal_array[SIGNAL_ARRAY_LEN - ADC_SAMPLES_NUMBER];      	// Data buffer start - end of sygnal_array
    498          	ADC10SA = (u16) &signal_array[0];	// Data buffer start - end of sygnal_array
    499          	ADC10CTL0 |= ENC + ADC10SC;         // Sampling and conversion start
    500          	//
    501          	
    502          	__enable_interrupt();                     // enable interrupts
    503          }
    504          
    505          
    506          
    507          u16 last_0_level;
    508          u16 last_level;
    509          
    510          //--------------------------------------------------------------------------------
    511          // Function		: void VLO_TimerCalibr(void)
    512          // Parameters	: None
    513          // Return		: 0 - no valid array, 1
    514          // Description	: The analysis of the input signal on ADC_SAMPLES_NUMBER samples
    515          //--------------------------------------------------------------------------------
    516          u16 AbsValue(u16 x1, u16 x2) {
    517          	if (x1 >= x2) {
    518          		return (x1 - x2);
    519          	}else{
    520          		return (x2 - x1);
    521          	}
    522          }
    523          
    524          /**************************************************************
    525          WinFilter version 0.8
    526          http://www.winfilter.20m.com
    527          akundert@hotmail.com
    528          
    529          Filter type: Band Pass
    530          Filter model: Butterworth
    531          Filter order: 8
    532          Sampling Frequency: 109 KHz
    533          Fc1 and Fc2 Frequencies: 3.800000 KHz and 14.000000 KHz
    534          Coefficents Quantization: 8-bit
    535          
    536          Z domain Zeros
    537          z = -1.000000 + j 0.000000
    538          z = -1.000000 + j 0.000000
    539          z = -1.000000 + j 0.000000
    540          z = -1.000000 + j 0.000000
    541          z = -1.000000 + j 0.000000
    542          z = -1.000000 + j 0.000000
    543          z = -1.000000 + j 0.000000
    544          z = -1.000000 + j 0.000000
    545          z = 1.000000 + j 0.000000
    546          z = 1.000000 + j 0.000000
    547          z = 1.000000 + j 0.000000
    548          z = 1.000000 + j 0.000000
    549          z = 1.000000 + j 0.000000
    550          z = 1.000000 + j 0.000000
    551          z = 1.000000 + j 0.000000
    552          z = 1.000000 + j 0.000000
    553          
    554          Z domain Poles
    555          z = 0.644814 + j -0.260807
    556          z = 0.644814 + j 0.260807
    557          z = 0.756494 + j -0.196546
    558          z = 0.756494 + j 0.196546
    559          z = 0.587475 + j -0.386644
    560          z = 0.587475 + j 0.386644
    561          z = 0.840396 + j -0.195195
    562          z = 0.840396 + j 0.195195
    563          z = 0.588237 + j -0.523443
    564          z = 0.588237 + j 0.523443
    565          z = 0.901607 + j -0.202202
    566          z = 0.901607 + j 0.202202
    567          z = 0.951542 + j -0.212108
    568          z = 0.951542 + j 0.212108
    569          z = 0.642148 + j -0.658914
    570          z = 0.642148 + j 0.658914
    571          ***************************************************************/
    572          
    573          #define Ntap 18
    574          
    575          // !!! See division by DCgain below
    576          #define DCgain 512	
    577          
    578          //const s16 FIRCoef[Ntap] = { 
    579          const s8 FIRCoef[Ntap] = { 
    580                    -13,
    581                    -32,
    582                    -52,
    583                    -59,
    584                    -43,
    585                     -2,
    586                     50,
    587                     95,
    588                    113,
    589                     95,
    590                     50,
    591                     -2,
    592                    -43,
    593                    -59,
    594                    -52,
    595                    -32,
    596                    -13,
    597                     -3
    598          };
    599          
    600          
    601          static s16 	x[Ntap] = {0};	//, 512, 512, 512 }; 	//input samples
    602          
    603          s16 fir_filter(s16 sample) {
    604              s32	 		y = 0;      //output sample
    605              int 		i;
    606          	
    607              // Shift the old samples
    608              for(i = Ntap-1; i > 0; i--) {
    609          		x[i] = x[i-1];
    610          	}
    611          	
    612              // Calculate the new output
    613              x[0] = sample;
    614              for(i = 0; i < Ntap; i++) {
    615          		y += (s32)FIRCoef[i] * x[i];
    616          	}
    617          	
    618          	if (y >= 0) {
    619          		y = y >> 9;
    620          	}else{
    621          		y = y / DCgain;	
    622          	}
    623          	
    624              return y;	// / DCgain;
    625          }
    626          
    627          
    628          
    629          
    630          //--------------------------------------------------------------------------------
    631          // Function		: void VLO_TimerCalibr(void)
    632          // Parameters	: None
    633          // Return		: 0 - no signal, 1 - signal is existing
    634          // Description	: The analysis of the input signal on ADC_SAMPLES_NUMBER samples
    635          //--------------------------------------------------------------------------------
    636          u8 DefineNewMode(u16 delta) {
    637          	
    638          	return 0;
    639          }
    640          
    641          
    642          //s16	adc_back1[ADC_SAMPLES_NUMBER];
    643          
    644          volatile s16	d1, d2, d3, d4;
    645          
    646          #define EXT_ARRAY_LEN	7
    647          
    648          //--------------------------------------------------------------------------------
    649          // Function		: void VLO_TimerCalibr(void)
    650          // Parameters	: None
    651          // Return		: 0 - no signal, 1 - signal is existing
    652          // Description	: The analysis of the input signal on ADC_SAMPLES_NUMBER samples
    653          //--------------------------------------------------------------------------------
    654          //#pragma optimize=none
    655          u8 SignalAnalysis(void) {
    656          	int i;
    657          	s16	sample;
    658          	s16 min = 2048, max = -2048;
    659          	int i_min = 0, i_max = 0;
    660          	u8 array_hi[EXT_ARRAY_LEN];
    661          	u8 array_lo[EXT_ARRAY_LEN];
    662          	u8 i_hi = 0;
    663          	u8 i_lo = 0;
    664          	s8 T = 0;
    665          	u8 ret = 0;
    666          	
    667          	// 
    668              for(i = 1; i < Ntap; i++) {
    669          		x[i] = 0;	//signal_array[i] - 220;
    670          	}
    671          	
    672          	sample = AverageData((u16 *)&signal_array[0], 16);
    673          	
    674          	// Filtering with use FIR
    675          	for (i = 0; i < SIGNAL_ARRAY_LEN; i++) {
    676          		//signal_array[i] = fir_filter(adc_data1[j++] - 512);
    677          		signal_array[i] = fir_filter(signal_array[i] - sample);	
    678          	}
    679          	
    680          	
    681          	// Searching for of importance of the amplitude of the signal on possible gap of time
    682          	for (i = 15; i < SIGNAL_ARRAY_LEN - 2; i++) {
    683          		sample = signal_array[i];
    684          		if (((sample >  signal_array[i - 1]) && (sample >  signal_array[i + 1]) && (sample > signal_array[i - 2]) && (sample > signal_array[i + 2])) ||
    685          		    ((sample >  signal_array[i - 1]) && (sample == signal_array[i + 1]) && (sample > signal_array[i - 2]) && (sample > signal_array[i + 2])) || 
    686          			((sample == signal_array[i - 1]) && (sample == signal_array[i + 1]) && (sample > signal_array[i - 2]) && (sample > signal_array[i + 2])) )   {
    687          	
    688          			if (sample > 10) {	
    689          				array_hi[i_hi] = i;
    690          				if (i_hi < EXT_ARRAY_LEN - 1) i_hi++;
    691          			}
    692          			
    693          			
    694          		}
    695          		
    696          		if (((sample <  signal_array[i - 1]) && (sample <  signal_array[i + 1]) && (sample < signal_array[i - 2]) && (sample < signal_array[i + 2])) ||
    697          		    ((sample <  signal_array[i - 1]) && (sample == signal_array[i + 1]) && (sample < signal_array[i - 2]) && (sample < signal_array[i + 2])) || 
    698          			((sample == signal_array[i - 1]) && (sample == signal_array[i + 1]) && (sample < signal_array[i - 2]) && (sample < signal_array[i + 2])) )   {
    699          		
    700          			if (sample < (-10)) {	
    701          				array_lo[i_lo] = i;
    702          				if (i_lo < EXT_ARRAY_LEN - 1) i_lo++;
    703          			}
    704          			
    705          		}
    706          			
    707          		if (sample < min) {
    708          			min = sample;
    709          			i_min = i;
    710          		}
    711          		if (sample > max) {
    712          			max = sample;
    713          			i_max = i;
    714          		}
    715          	}
    716          
    717          	//
    718          	delta = 0;
    719          	
    720          	// Filtering
    721          	/*
    722          	if (i_max > i_min) {
    723          		fError = 1;
    724          	}
    725          	*/
    726          	
    727          	if ((i_lo < 2) || (i_hi < 3)) {
    728          		// Low signal
    729          		ret = 1;
    730          	}else{
    731          		T = array_hi[1] - array_hi[0];
    732          		if ((T < 9) || (T > 15))  {
    733          			// High signal
    734          			ret = 2;
    735          		}
    736          	}
    737          	
    738          	d1 = signal_array[array_hi[0]] - signal_array[array_hi[1]];
    739          	if (((d1 < -50) || (d1 > 50)) && (amp_no == 1)){
    740          		// Wery high signal
    741          		ret = 2;
    742          	}
    743          	
    744          	// Definition of delta
    745          	// Define of first low extremum after first hi extremum
    746          	for (i = 0; i < EXT_ARRAY_LEN; i++) {
    747          		if (array_lo[i] > array_hi[0]) {
    748          			i_hi = 0;
    749          			i_lo = i;
    750          			break;
    751          		}
    752          	}
    753          	//
    754          	/* ////
    755          	i_hi++;
    756          	d1 = signal_array[array_hi[i_hi++]] - signal_array[array_lo[i_lo++]];
    757          	d2 = signal_array[array_hi[i_hi]] - signal_array[array_lo[i_lo]];
    758          	delta = (d1 + d2) / 2;
    759          	*/
    760          	
    761          	//i_lo++;
    762          	d1 = signal_array[array_hi[i_hi++]] - signal_array[array_lo[i_lo]];
    763          	d2 = signal_array[array_hi[i_hi]] - signal_array[array_lo[i_lo++]];
    764          	d3 = signal_array[array_hi[i_hi++]] - signal_array[array_lo[i_lo]];
    765          	d4 = signal_array[array_hi[i_hi]] - signal_array[array_lo[i_lo]];
    766          
    767          	delta = (d1 + d2 + d3 + d4) / 4;
    768          	
    769          	if (delta > 4000) {
    770          		delta = 0;	//CONFIG->limit_norm;
    771          	}
    772          	
    773          	if ((DeviceMode == MODE_CALIBR) && ret) {
    774          		delta = 0;
    775          	}
    776          	//
    777          	return ret;
    778          }
    779          
    780          
    781          
    782          //--------------------------------------------------------------------------------
    783          // Function		: void Timer_A0_SetDelay(u16 period)
    784          // Parameters	: period in us (1..65535) - for 8 MHz DCO
    785          // Return		: None
    786          // Description	: Function initiates delay
    787          //--------------------------------------------------------------------------------
    788          void Timer_A0_SetDelay(u16 period) {
    789          	
    790          	if (period == 0) return;
    791          	
    792          	_BIC_SR(GIE);    					// Запрещаем прерывания
    793          	
    794          	fTimerA_Enable = 1;
    795          	fTimerA_Repeat = 0;
    796          	//
    797          	TA0R = 0;
    798          	TACTL 	 = TASSEL_2 + MC_1 + ID_3;  // SMCLK, up mode, div = 8
    799          	CCR0 	 = period - 1;      		// Period T(us) * F(MHz)
    800          	TACCTL0 = CCIE;						// Разрешаем прерывание таймера по достижению значения TACCCR0.
    801          	//
    802          	_BIS_SR(GIE);    					// Разрешаем прерывания
    803          }
    804          
    805          //--------------------------------------------------------------------------------
    806          // Function		: void TimerA1_DelayUs(u16 time)
    807          // Parameters	: period in us (1..32768) - for 1 MHz DCO
    808          // Return		: None
    809          // Description	: Function initiates 
    810          //--------------------------------------------------------------------------------
    811          #pragma optimize=none
    812          void TimerA1_DelayUs(u16 time) {
    813          	_BIC_SR(GIE);    					// Запрещаем прерывания
    814          	
    815          	//
    816          	TA1R = 0;
    817          	TA1CTL 	 = TASSEL_2 + MC_1;     	// SMCLK, up mode, div = 8
    818          	TA1CCR0 	 = time - 1 - 35;      	// Period T(us) * F(MHz)
    819          	//
    820          	_BIS_SR(GIE);    					// Разрешаем прерывания
    821          	
    822          	while ((TA1CCTL0 & CCIFG) == 0);
    823          	
    824          	TA1CTL 	 = 0;
    825          	TA1CCTL0 = 0;
    826          
    827          	/*
    828          	TA1R = 0;
    829          	TA1CTL 	 = TASSEL_2 + MC_1 + ID_0;  // SMCLK, up mode, div = 1
    830          	TA1CCR0  = SYS_TICK_TIME - 1;   	// Period T(us) * F(MHz)
    831          	*/
    832          }
    833          
    834          
    835          //--------------------------------------------------------------------------------
    836          // Function		: void Timer_A1_Init(void)
    837          // Parameters	: period in us (1..65535) - for 1 MHz DCO
    838          // Return		: None
    839          // Description	: Function initiates delay
    840          //--------------------------------------------------------------------------------
    841          void Timer_A1_Init(void) {
    842          	_BIC_SR(GIE);    					// Запрещаем прерывания
    843          	//
    844          	TA1R = 0;
    845          	TA1CTL 	 = TASSEL_2 + MC_1 + ID_0;  // SMCLK, up mode, div = 1
    846          	TA1CCR0  = SYS_TICK_TIME - 1;   	// Period T(us) * F(MHz)
    847          	TA1CCTL0 = CCIE;					// Разрешаем прерывание таймера по достижению значения TACCCR0.
    848          	//
    849          	_BIS_SR(GIE);    					// Разрешаем прерывания
    850          }
    851          
    852          
    853          //--------------------------------------------------------------------------------
    854          // Function		: void SoundStart(u8 snd_ind)
    855          // Parameters	: period in us (1..32768) - for 16 MHz DCO
    856          // Return		: None
    857          // Description	: Function initiates 
    858          //--------------------------------------------------------------------------------
    859          void Timer_A0_Off(void) {
    860          	_BIC_SR(GIE);    			// Запрещаем прерывания
    861          	//	
    862          	fTimerA_Enable = 0;
    863          	fTimerA_Repeat = 0;
    864          	//
    865          	TACTL = 0;  
    866          	TACCTL0 = 0;				// Запрещаем прерывание таймера по достижению значения TACCCR0.
    867          	//
    868          	_BIS_SR(GIE);    			// Разрешаем прерывания
    869          
    870          }
    871          
    872          
    873          //--------------------------------------------------------------------------------
    874          // Function		: void SetFaultMode(void)
    875          // Parameters	: None
    876          // Return		: None
    877          // Description	: 
    878          //--------------------------------------------------------------------------------
    879          void SetFaultMode(void) {
    880          	
    881          	DeviceMode = MODE_FAULT;
    882          	//
    883          	if (fault_timer == 0) { 
    884          		// No faults
    885          		fault_timer = 1000;		// 10 sec
    886          		fault_phase = 1;		// Break of BI
    887          	}
    888          	//
    889          	strob_pulse_timer = 0;		// Clear strob timer because there is breaking BI
    890          }
    891          
    892          
    893          
    894          //--------------------------------------------------------------------------------
    895          // Function		: void FaultSignalManager(void)
    896          // Parameters	: None
    897          // Return		: None
    898          // Description	: Call one time per 10 ms
    899          //--------------------------------------------------------------------------------
    900          void FaultSignalManager(void) {
    901          	
    902          	if ((DeviceMode == MODE_FIRE) || (DeviceMode == MODE_TEST) || (DeviceMode == MODE_CALIBR)) {
    903          		return;
    904          	}
    905          	//
    906          	if (DeviceFault.byte) {
    907          		DeviceMode = MODE_FAULT;
    908          		led_r = 0;
    909          		
    910          		if (DeviceFault.fStrobNone) {
    911          			// Electrical sync is fault
    912          			led_y = LED_PULSE_2;
    913          		}else
    914          		if (DeviceFault.fSignal_Low) {
    915          			// Level signal is very low
    916          			led_y = LED_PULSE_1;
    917          		}else	
    918          		if (DeviceFault.fFaultDrift) {
    919          			// Long Term Drift fault
    920          			led_y = LED_PULSE_3;
    921          		}else	
    922          		if (DeviceFault.fSignal_Hi) {
    923          			// Level signal is very big
    924          			led_y = LED_PULSE_5;
    925          		}
    926          		
    927          	}
    928          	
    929          	if (CalibrFault.byte) {
    930          		// Calibration fault signals
    931          		
    932          		DeviceMode = MODE_FAULT;
    933          		led_r = 0;
    934          		
    935          		if (CalibrFault.fCalibr_Low) {
    936          			led_y = LED_PULSE_4;
    937          		}else
    938          		if (CalibrFault.fCalibr_Hi) {
    939          			led_y = LED_PULSE_5;
    940          		}
    941          		//
    942          		BREAK_ENABLE();				// Disable of BI
    943          		FIRE_CLR();					// Disable Fire current consumption
    944          		//
    945          		fault_timer = 0;
    946          		fault_phase = 0;
    947          	}
    948          		
    949          	if ((DeviceFault.byte == 0) && (CalibrFault.byte == 0)) {
    950          		if (DeviceMode == MODE_FAULT) {
    951          			DeviceMode = MODE_NORM;
    952          			
    953          			led_r = 0;
    954          			led_y = 0;
    955          			
    956          			fault_timer = 0;
    957          			fault_phase = 0;
    958          			
    959          			strob_pulse_timer = 0;
    960          			
    961          			BREAK_DISABLE();		// Enable of BI
    962          			FIRE_CLR();				// Disable Fire current consumption
    963          		}
    964          	}
    965          	//
    966          	if (fault_timer) {
    967          		fault_timer--;
    968          		//
    969          		if (fault_timer == 0) {
    970          			if (fault_phase) {
    971          				fault_phase = 0;
    972          				fault_timer = 2000;		// 20 sec
    973          			}else{
    974          				fault_phase = 1;
    975          				fault_timer = 1000;		// 10 sec
    976          			}
    977          		}
    978          		//
    979          		if (fault_phase == 1) {
    980          			BREAK_ENABLE();			// Disable of BI
    981          		}else{
    982          			BREAK_DISABLE();		// Enable of BI
    983          		}
    984          
    985          	}
    986          }
    987          
    988          
    989          //--------------------------------------------------------------------------------
    990          // Function		: void LedTestValueManager(void)
    991          // Parameters	: None
    992          // Return		: None
    993          // Description	: 
    994          //--------------------------------------------------------------------------------
    995          //#pragma optimize=none
    996          void LedTestValueManager(void) {
    997          	if (delta < 150) {
    998          		led_r = LED_PULSE_1;
    999          		led_y = LED_FULL;
   1000          	}else
   1001          	if (delta < 250) {
   1002          		led_r = LED_PULSE_2;
   1003          		led_y = LED_FULL;
   1004          	}else
   1005          	if (delta < 450) {
   1006          		led_r = LED_PULSE_3;
   1007          		led_y = LED_FULL;
   1008          	}else
   1009          	if (delta < 550) {
   1010          		led_r = LED_PULSE_4;
   1011          		led_y = LED_FULL;
   1012          	}else{
   1013          		led_r = LED_PULSE_5;
   1014          		led_y = LED_FULL;
   1015          	}
   1016          }
   1017          
   1018          
   1019          //---------------------------------------------------------------------------------
   1020          // Function		: void AMP_SetGain(u8 value)
   1021          // Parameters	: None
   1022          // Return		: None
   1023          // Description	: Initialization interrupts from RX Sniff CC112x (GPIO2)
   1024          //---------------------------------------------------------------------------------
   1025          void ADC_SetParam(void) {
   1026          	
   1027          	gain = CONFIG->Gain & 0x0F;
   1028          	reference = CONFIG->Gain >> 4;
   1029          	amp_no = CONFIG->AMP_No;
   1030          	
   1031          }
   1032          
   1033          //---------------------------------------------------------------------------------
   1034          // Function		: void AMP_SetGain(u8 value)
   1035          // Parameters	: None
   1036          // Return		: None
   1037          // Description	: Initialization interrupts from RX Sniff CC112x (GPIO2)
   1038          //---------------------------------------------------------------------------------
   1039          #pragma optimize=none
   1040          void CalibrationResultAnalise(void) {
   1041          	int i;
   1042          	u16 prev, temp, min = 0xFFFF, max = 0;
   1043          	u8  i_ok = 0xFF, i_ok2 = 0xFF;
   1044          	u8  fault = 0;
   1045          	u16 d;
   1046          	u8  corr = 0;
   1047          	
   1048          	prev = s_array[0];
   1049          	for (i = 0; i < CALIBR_STAGES; i++) {
   1050          		temp = s_array[i];
   1051          		//
   1052          		if (temp > max) {
   1053          			max = temp;
   1054          		}
   1055          		if (temp < min) {
   1056          			min = temp;
   1057          		}
   1058          			
   1059          		if (((temp >= 90) && (temp <= 200)) || 
   1060          			((temp >= 480) && (temp <= 600))) {
   1061          			i_ok = i;
   1062          		}
   1063          		if ((temp >= 200) && (temp <= 480)) {
   1064          			i_ok2 = i;
   1065          		}
   1066          		//
   1067          		if ((prev > 100) && (temp == 0) && (i <= 4)) {
   1068          			fault = 1;	// Signal is vefy Hi
   1069          		}
   1070          		prev = temp;
   1071          	}
   1072          	//
   1073          	if (q_array[0] == 2) {
   1074          		// Signal is vefy Hi
   1075          		fault = 1;
   1076          	}
   1077          	//
   1078          		
   1079          	if (fault) {
   1080          		// End of calibration - very Hi signal - ERROR
   1081          		//DeviceFault.fSignal_Hi = 1;
   1082          		//DeviceMode = MODE_FAULT;
   1083          		CalibrFault.fCalibr_Hi = 1;
   1084          	}else
   1085          	if ((i_ok2 < CALIBR_STAGES) || (i_ok < CALIBR_STAGES)) {
   1086          		if (i_ok2 < CALIBR_STAGES) {
   1087          			i = i_ok2; 
   1088          		}else{
   1089          			i = i_ok;
   1090          		}
   1091          		//
   1092          		// Calibration Ok!!!
   1093          		//
   1094          		d = s_array[i];
   1095          		//q = q_array[i]; 
   1096          		//
   1097          		if (i == 0) {
   1098          			if (d >= 480) {
   1099          				CalibrFault.fCalibr_Hi = 1;
   1100          				StoragePropertyByte(eeCALIBR_FAULT_OFFSET, CalibrFault.byte);
   1101          				return;
   1102          			}
   1103          			//
   1104          			if (d >= 330) {
   1105          				corr = 2;
   1106          			}else
   1107          			if (d >= 170) {
   1108          				corr = 1;
   1109          			}
   1110          		}
   1111          			
   1112          		// That's Ok
   1113          		//SetLevels(d);
   1114          		SetLevelsFromCalibr(d, corr);
   1115          		SetLimitCompens();
   1116          		
   1117          		amp_no = calibr_sequence[i][0];
   1118          		gain = calibr_sequence[i][1];
   1119          		reference = calibr_sequence[i][2];
   1120          		
   1121          		StoragePropertyByte(ee_GAIN, gain + (reference << 4));
   1122          		StoragePropertyByte(ee_AMP_NO, amp_no);
   1123          		StoragePropertyWord(eeCONFIG_REG_OFFSET, cfg_reg.word);
   1124          		//
   1125          		DeviceMode = MODE_NORM;
   1126          		//...
   1127          		FIRE_CLR();				// Disable Fire current consumption
   1128          		//
   1129          		AMP_SetGain(gain);
   1130          		//
   1131          	}else
   1132          	if (max < SYGNAL_MIN_VALUE) {
   1133          		// Signal is Low
   1134          		CalibrFault.fCalibr_Low = 1;
   1135          	}else
   1136          	if (min > SYGNAL_MAX_VALUE) {
   1137          		// Signal is Hi
   1138          		CalibrFault.fCalibr_Hi = 1;
   1139          	}
   1140          	//
   1141          	FIRE_CLR();				// Disable Fire current consumption
   1142          	StoragePropertyByte(eeCALIBR_FAULT_OFFSET, CalibrFault.byte);
   1143          }
   1144          	
   1145          
   1146          //========================================================
   1147          //                 ---  M A I N  ----
   1148          //========================================================
   1149          //--------------------------------------------------------------------------------
   1150          // Function		: void main(void)
   1151          // Parameters	: None
   1152          // Return		: None
   1153          // Description	: Main function. Contains main loop.
   1154          //--------------------------------------------------------------------------------
   1155          void main(void) {
   1156          	u8	byte, sh, len;
   1157          	int i;
   1158          	u8  loc_buf[2];
   1159          	u8  n_counter = 0;
   1160          	u8  quality;
   1161          	u16	summa = 0;
   1162          	u8	fire_level_counter = 0;
   1163          	u8	QualityFaultCounter = 0;
   1164          	u8	led_clk;
   1165          	u16	led_timer = 0;
   1166          	u8	timerA1_blank = 0;
   1167          	
   1168          	// Initialization variables and GPIO
   1169          	WDTCTL = WDTPW + WDTHOLD;				// отключаем сторожевой таймер
   1170          	// GIPIO Init
   1171          	GPIO_Init();
   1172          		
   1173          	// Init internal RC osc.
   1174          	BCSCTL1 = CALBC1_1MHZ; 					// Используем частоту 1 MГц
   1175          	DCOCTL =  CALDCO_1MHZ;
   1176          	
   1177          	DelayMs(100);
   1178          	
   1179          	// Initialization code for VLO
   1180          	__set_R4_register(0);
   1181          	//
   1182          	BCSCTL3 |= LFXT1S_2;                    // Select VLO as low freq clock
   1183          	// End initialization code
   1184          	
   1185          	WDTCTL = WDT_ADLY_16;                   // Interval timer	/* for 50 ms */
   1186          	//WDTCTL = WDT_ADLY_1_9;                   // Interval timer	/* for 5.9 ms */
   1187          	IE1 |= WDTIE;                           // Enable WDT interrupt
   1188          	//
   1189          	if (IFG1 & WDTIFG) {
   1190          		// Reset WDT
   1191          		#if (SYS_FAULT_ENABLE == 1)
   1192          		DeviceFault.fFaultSWReset = 1;
   1193          		#endif
   1194          	}
   1195          	IFG1 = 0;
   1196          	//	
   1197          	DeviceMode = MODE_NORM;
   1198          	
   1199          	//!!!!
   1200          	TEST2_DIR |= TEST2_BIT;
   1201          		
   1202          	DelayMs(2000);
   1203          	
   1204          	Led_Flash(10);
   1205          	DelayMs(300);
   1206          	Led_Flash(10);
   1207          	
   1208          	BREAK_DISABLE();					// Enable BI
   1209          	DelayMs(7000);
   1210          	
   1211          	_BIS_SR(GIE);    					// Interrupt enable
   1212          	DeviceStart();
   1213          
   1214          	AMP_SetGain(CONFIG->Gain);
   1215          	ADC_SetParam();
   1216          	cfg_reg = CONFIG->config_reg;
   1217          	
   1218          	STROB_IE_Enable();
   1219          	Timer_A1_Init();
   1220          	
   1221          	DelayMs(2000);
   1222          	
   1223          	start_timer = 400;		// 4 sec
   1224          	
   1225          // *****************************************************************
   1226          // ******************   M A I N   L O O P  *************************
   1227          // *****************************************************************
   1228          	while(1) {
   1229          		
   1230          		//-------------------------------------------------------------------------------
   1231          		//
   1232          		// ******** Обработчики событий ********
   1233          		//
   1234          		//-------------------------------------------------------------------------------
   1235          		
   1236          //-------------------------------------------------------------------------------
   1237          // TimerA0 Event		
   1238          //-------------------------------------------------------------------------------
   1239          		if (fTimerA_On) {				// Закончен период ожидания измерительных импульсов
   1240          			fTimerA_On = 0;
   1241          			
   1242          			BCSCTL1 = CALBC1_16MHZ; 	// Используем частоту 16 MГц
   1243          			DCOCTL =  CALDCO_16MHZ;
   1244          			//
   1245          			TA1CCR0  = 0xFFFF - 1;   	// ~ Compensation of frequence increase
   1246          			//
   1247          			Timer_A0_Off();				
   1248          			
   1249          			ADC_MeasureStart();
   1250          		
   1251          			timerA1_blank = 4;
   1252          		}
   1253          
   1254          //-------------------------------------------------------------------------------
   1255          // fTimer50msOn Event				
   1256          //-------------------------------------------------------------------------------
   1257          		if (fTimer50msOn) {		// Получен следующий 50мс интервал
   1258          			fTimer50msOn = 0;
   1259          			//
   1260          			Timer50msCounter = 0;
   1261          		}
   1262          		
   1263          //-------------------------------------------------------------------------------
   1264          // TimerA1 Event (SysTick) 10 ms
   1265          //-------------------------------------------------------------------------------
   1266          		if (fTimerA1_On) {				// Получен следующий интервал timer
   1267          			fTimerA1_On = 0;
   1268          			
   1269          			if (start_timer) {
   1270          				start_timer--;
   1271          				if (start_timer == 0) {
   1272          					CalibrFault.byte = CONFIG->calibr_fault;
   1273          					////if (CalibrFault.byte) {
   1274          					////	DeviceMode = MODE_FAULT;
   1275          					////}
   1276          					//
   1277          					flash_period_timer = 500;	// Need flash after 5 sec
   1278          					strob_pulse_timer = 0;
   1279          				}
   1280          			}
   1281          			
   1282          			//TEST2_OUT ^= TEST2_BIT;
   1283          			//
   1284          			if (timerKeyDown) {
   1285          				timerKeyDown++;
   1286          				if (timerKeyDown > 200 ) {			// > 2 sec - Start Calibration
   1287          					// CALIBRATION Start
   1288          					//
   1289          					JP1_Define();			// Define JP1 on BVS state
   1290          					if (jp1_state == 0) {
   1291          						// JP1 is Open 
   1292          						cfg_reg.fDrift = 1;
   1293          					}else{
   1294          						cfg_reg.fDrift = 0;
   1295          					}
   1296          					//
   1297          					// Calibration mode init 
   1298          					DeviceMode = MODE_CALIBR;
   1299          					
   1300          					// Calibration from most amp to small
   1301          					FIRE_SET();				// Set Fire output key
   1302          					FAULT_CLR();			// Clear Fault Signal
   1303          					BREAK_DISABLE();		// Enable of transmitter
   1304          					
   1305          					DeviceFault.fStrobNone = 0;
   1306          					strob_pulse_timer = 0;
   1307          					//
   1308          					calibr_stage = 0;
   1309          					n_counter = 0;
   1310          					summa = 0;
   1311          					//
   1312          					amp_no = calibr_sequence[calibr_stage][0];
   1313          					gain = calibr_sequence[calibr_stage][1];
   1314          					reference = calibr_sequence[calibr_stage][2];
   1315          					//
   1316          					AMP_SetGain(gain);
   1317          					
   1318          					QualityFaultCounter = 0;
   1319          					DeviceFault.byte = 0;
   1320          					CalibrFault.byte = 0;
   1321          					fault_timer = 0;
   1322          					fault_phase = 0;
   1323          					
   1324          					RED_CLR();
   1325          					YEL_CLR();
   1326          					
   1327          					timerKeyDown = 0;
   1328          					
   1329          					flash_period_timer = 120;	// Flash after 1.2 sec
   1330          					light_timer = 7;			// Value - the power of LED light
   1331          				}
   1332          			}
   1333          			
   1334          			if (zero_timer) {
   1335          				zero_timer++;
   1336          			}
   1337          				
   1338          			if (fault_chain_timer)  {
   1339          				fault_chain_timer--;
   1340          				if (DeviceMode != MODE_FIRE) {
   1341          					if (fault_chain_timer == 0) {
   1342          						if (fault_sequence[fault_chain_ind] == 0) {
   1343          							fault_chain_ind = 0;
   1344          							DeviceMode = MODE_NORM;
   1345          						}else{
   1346          							DeviceMode = fault_sequence[fault_chain_ind++];
   1347          							fault_chain_timer = getTimerValue(fault_sequence[fault_chain_ind++]);
   1348          							//
   1349          							switch (DeviceMode) {
   1350          								case MODE_FIRE:
   1351          									FIRE_SET();
   1352          									//
   1353          									RED_SET();
   1354          									YEL_CLR();
   1355          									fault_chain_timer = 0;
   1356          									strob_pulse_timer = 0;
   1357          									zero_timer = 0;
   1358          									BREAK_DISABLE();		// Enable of transmitter
   1359          									DeviceFault.fSignal_Low = 0;
   1360          									break;
   1361          								case MODE_FAULT:
   1362          									BREAK_ENABLE();			// Disable of transmitter
   1363          									break;
   1364          								case MODE_NORM:
   1365          									strob_pulse_timer = 0;
   1366          									zero_timer = 0;
   1367          									DeviceFault.fSignal_Low = 0;
   1368          									BREAK_DISABLE();		// Enable of transmitter
   1369          							}
   1370          						}
   1371          					}
   1372          				}
   1373          			}
   1374          			
   1375          			if (timerMain) {
   1376          				timerMain--;
   1377          				if (timerMain == 0) {
   1378          					if (DeviceMode == MODE_TEST) {
   1379          						DeviceMode = MODE_NORM;
   1380          						RED_CLR();
   1381          						YEL_CLR();
   1382          						FIRE_CLR();
   1383          					}
   1384          				}
   1385          			}
   1386          			//
   1387          			// Setting signals in Fault Mode (LEDs and other pins)
   1388          			FaultSignalManager();
   1389          			//
   1390          			
   1391          			if (timerA1_blank) {
   1392          				timerA1_blank--;
   1393          			}else{
   1394          				// ---- LED Indication ----
   1395          				//
   1396          				if (light_timer) {
   1397          					light_timer--;
   1398          					//
   1399          					if ((DeviceMode == MODE_NORM) || (DeviceMode == MODE_PREFIRE) || (DeviceMode == MODE_PREPREFIRE)) {
   1400          						RED_SET();
   1401          						YEL_CLR();
   1402          					}else
   1403          					//
   1404          					if (DeviceMode == MODE_CALIBR) {
   1405          						RED_SET();
   1406          						YEL_SET();
   1407          					}
   1408          				}else{
   1409          					//
   1410          					if ((DeviceMode == MODE_NORM) || (DeviceMode == MODE_CALIBR) || (DeviceMode == MODE_PREFIRE) || (DeviceMode == MODE_PREPREFIRE)) {
   1411          						RED_CLR();
   1412          						YEL_CLR();
   1413          					}
   1414          				}
   1415          				//	
   1416          				if ((DeviceMode == MODE_FAULT) || (DeviceMode == MODE_TEST)) {
   1417          					//
   1418          					// LED management
   1419          					//
   1420          					if (light_sync >= 3) {
   1421          						light_sync = 0;
   1422          						led_sh = 0x80000000;
   1423          						//
   1424          						led_timer = 300;		// 3 sec period
   1425          					}
   1426          					
   1427          					if (led_timer) {
   1428          						led_timer--;
   1429          					}else{
   1430          						led_timer = 300;		// 3 sec period
   1431          						led_sh = 0x80000000;
   1432          						//
   1433          						light_sync = 0;
   1434          					}
   1435          					//
   1436          					if (++led_clk >= 4) {		// T = 30 ms
   1437          						led_clk = 0;
   1438          						//
   1439          						if (led_r & led_sh) {
   1440          							RED_SET();
   1441          							TEST2_SET();
   1442          						}else{
   1443          							RED_CLR();
   1444          							TEST2_CLR();
   1445          						}
   1446          						//
   1447          						if (led_y & led_sh) {
   1448          							YEL_SET(); 
   1449          						}else{
   1450          							YEL_CLR();
   1451          						}
   1452          						//
   1453          						if (DeviceMode == MODE_TEST) {
   1454          							YEL_SET(); 
   1455          						}
   1456          						//
   1457          						led_sh >>= 1;
   1458          					}
   1459          				}
   1460          			} // End indication
   1461          			//
   1462          			//
   1463          			// Strob pulse diagnostic 
   1464          			if ((strob_pulse_timer == 200) || (strob_pulse_timer == 1800)){
   1465          				STROB_IE_Enable();
   1466          			}
   1467          			if (++strob_pulse_timer >= 2000) {	// 20 sec
   1468          				strob_pulse_timer = 0;
   1469          				if (DeviceFault.fStrobNone == 0) {
   1470          					if (CalibrFault.byte == 0) {
   1471          						DeviceFault.fStrobNone = 1;
   1472          						SetFaultMode();
   1473          					}
   1474          				}
   1475          			}
   1476          			//
   1477          			if (flash_period_timer) {
   1478          				flash_period_timer--;
   1479          				if (flash_period_timer == 0) {
   1480          					flash_period_timer = 120;	// Flash after 1.2 sec
   1481          					if ((DeviceMode == MODE_NORM) || (DeviceMode == MODE_PREPREFIRE)){
   1482          						light_timer = 1;				// Value - the light power
   1483          					}else
   1484          					if (DeviceMode == MODE_CALIBR) {
   1485          						light_timer = 7;				// Value - the light power
   1486          					}
   1487          				}
   1488          			}
   1489          				
   1490          		} // if (fTimerA1_On 10 ms)
   1491          		
   1492          //-------------------------------------------------------------------------------
   1493          // End of samples of ADC Event
   1494          		if (fEndOfSamples) {	// End of samples of ADC Event
   1495          			fEndOfSamples = 0;
   1496          			
   1497          			//VREF_Off();						// Vref Disable
   1498          			ADC10CTL0 &= ~ENC;
   1499          			while (ADC10CTL1 & BUSY);           // Wait if ADC10 core is active 
   1500          			ADC10CTL0 &= ~REFON;
   1501          			
   1502          			AMP_PWR_OFF();						// AMP Power Supply Disable
   1503          			//AMP_Off_Timer = CONFIG->timer_calibr - CONFIG->timer_calibr / 4 + 1;	//CONFIG->timer_calibr - CONFIG->timer_calibr / 4 + 1;
   1504          			//
   1505          			BCSCTL1 = CALBC1_8MHZ; 					// Используем частоту 1 MГц
   1506          			DCOCTL =  CALDCO_8MHZ;
   1507          			//
   1508          			TA1CCR0  = 0xFFFF - 1;   			// ~ Compensation of frequence increase
   1509          			//
   1510          			DelayUs(1);
   1511          			//
   1512          			if (fSendingGraph) {
   1513          				loc_buf[0] = Q_SEND_GRAPH1;
   1514          				loc_buf[1] = SIGNAL_ARRAY_LEN * 2;
   1515          				SoftUART_TxString(loc_buf, 2);
   1516          				//
   1517          				SoftUART_TxString((u8*)&signal_array[0], SIGNAL_ARRAY_LEN * 2);
   1518          			}
   1519          			//
   1520          			//
   1521          			if (start_timer || CalibrFault.byte || DeviceFault.fFaultDrift) {
   1522          				goto label_light;
   1523          			}
   1524          			
   1525          			STROB_IE_Enable();
   1526          			strob_pulse_timer = 0;
   1527          		
   1528          			//TEST2_SET();
   1529          			quality = SignalAnalysis();
   1530          			//TEST2_CLR();
   1531          			//
   1532          			BCSCTL1 = CALBC1_1MHZ; 					// Используем частоту 1 MГц
   1533          			DCOCTL =  CALDCO_1MHZ;
   1534          			TA1CCR0  = 1 * SYS_TICK_TIME - 1;   	// Period T(us) * F(MHz)
   1535          			DelayUs(1);
   1536          			//
   1537          			//	
   1538          			if (DeviceMode == MODE_CALIBR) {
   1539          				//
   1540          				// -------- CALIBRATION ---------
   1541          				//
   1542          				n_counter++;
   1543          				summa += delta;
   1544          				
   1545          				if (n_counter >= 2) {
   1546          					delta = summa / n_counter;
   1547          					n_counter = 0;
   1548          					summa = 0;
   1549          					//
   1550          					s_array[calibr_stage] = delta;
   1551          					q_array[calibr_stage] = quality;
   1552          					//
   1553          					if (++calibr_stage >= CALIBR_STAGES) {
   1554          						// End of calibration
   1555          						//
   1556          						CalibrationResultAnalise();
   1557          						if (CalibrFault.byte) {
   1558          							DeviceMode = MODE_FAULT;
   1559          						}
   1560          						//
   1561          						goto label_light;
   1562          					}
   1563          					//
   1564          					//	Set new	 Amp_No	Gain  Reference
   1565          					amp_no = calibr_sequence[calibr_stage][0];
   1566          					gain = calibr_sequence[calibr_stage][1];
   1567          					reference = calibr_sequence[calibr_stage][2];
   1568          					//
   1569          					AMP_SetGain(gain);
   1570          					//
   1571          				}
   1572          			}else
   1573          			//
   1574          			// -------- NORM behavior -------------
   1575          			//
   1576          			if (quality == 2) {	
   1577          				// Very high signal
   1578          				if (++QualityFaultCounter > 10) {
   1579          					CalibrFault.fCalibr_Hi = 1;
   1580          					QualityFaultCounter = 0;
   1581          				}
   1582          				//
   1583          				goto label_light;
   1584          			}else{
   1585          				QualityFaultCounter = 0;
   1586          			}
   1587          			
   1588          			if (((DeviceMode == MODE_NORM) || (DeviceMode == MODE_PREPREFIRE)) && fault_chain_timer) {
   1589          				// Обрабатывается полное перекрытие
   1590          				if (delta > getZeroLevel()) {
   1591          					fault_chain_timer = 0;
   1592          					fault_chain_ind = 0;
   1593          					DeviceFault.fSignal_Low = 0;
   1594          				}
   1595          			}
   1596          			
   1597          			if (((DeviceMode == MODE_NORM) || (DeviceMode == MODE_PREPREFIRE)) && (fault_chain_timer == 0)) {
   1598          				if ((delta >= CONFIG->limit_fire) && (delta <= SYGNAL_MAX_VALUE)) {
   1599          					// Reset all counters
   1600          					fire_level_counter = 0;
   1601          					hi_signal_counter = 0;
   1602          					zero_timer = 0;
   1603          				}
   1604          								
   1605          				if (delta <= getZeroLevel()) {
   1606          					if (zero_timer == 0) {	
   1607          						zero_timer = 1;
   1608          					}else
   1609          					if (zero_timer > 1000) {	// 10 sec
   1610          						// Полное перекрытие 
   1611          						fault_chain_ind = 0;
   1612          						DeviceMode = fault_sequence[fault_chain_ind++];
   1613          						fault_chain_timer = getTimerValue(fault_sequence[fault_chain_ind++]);
   1614          						DeviceFault.fSignal_Low = 1;
   1615          						zero_timer = 0;
   1616          						//
   1617          						BREAK_ENABLE();			// Disable of transmitter
   1618          						//
   1619          					}
   1620          				}else{
   1621          					zero_timer = 0;
   1622          					//
   1623          					if (delta < CONFIG->limit_prefire) {
   1624          						DeviceMode = MODE_PREPREFIRE;
   1625          					}
   1626          					
   1627          					if (DeviceMode == MODE_PREPREFIRE) {
   1628          						if (delta > CONFIG->limit_prefire) {
   1629          							DeviceMode = MODE_NORM;
   1630          						}
   1631          					}
   1632          					
   1633          					if (delta < CONFIG->limit_fire) {
   1634          						fire_level_counter = 5;
   1635          						DeviceMode = MODE_PREFIRE;
   1636          					}
   1637          					
   1638          					// Hi signal management
   1639          					if (delta > SYGNAL_MAX_VALUE) {
   1640          						// Very high signal
   1641          						hi_signal_counter++;
   1642          						if (hi_signal_counter >= 10) {
   1643          							//DeviceMode = MODE_FAULT;
   1644          							CalibrFault.fCalibr_Hi = 1;
   1645          							hi_signal_counter = 0;
   1646          						}
   1647          					}
   1648          				}
   1649          			}else
   1650          			if (DeviceMode == MODE_PREFIRE) {
   1651          				//
   1652          				// Защита от плавного изменения уровня сигнала
   1653          				if ((delta == 0) && (delta_last > 0)) {
   1654          					fire_level_counter = 10;
   1655          				}
   1656          				//	
   1657          				if ((delta <= getZeroLevel()) && (fire_level_counter == 5)) {
   1658          					if (zero_timer == 0) {	
   1659          						zero_timer = 1;
   1660          						DeviceMode = MODE_NORM;
   1661          					}
   1662          				}else
   1663          				if (delta < CONFIG->limit_fire) {
   1664          					if (--fire_level_counter == 0) {
   1665          						DeviceMode = MODE_FIRE;
   1666          						FIRE_SET();
   1667          						RED_SET();
   1668          						YEL_CLR();
   1669          						DeviceFault.byte = 0;
   1670          					}
   1671          				}else{
   1672          					DeviceMode = MODE_NORM;
   1673          				}
   1674          				//
   1675          				delta_last = delta;
   1676          			}
   1677          			//
   1678          			if (CONFIG->config_reg.fDrift) {
   1679          				// if JP1 state is open
   1680          				if ((DeviceMode == MODE_NORM) && delta) {
   1681          					// Long Term Drift Adjustment
   1682          					DriftSumma += delta;
   1683          					DriftCounter++;
   1684          					if (DriftCounter >= DRIFT_SAMPLES_MAX) {
   1685          						DriftLevel = DriftSumma / DriftCounter;
   1686          						//
   1687          						if ((u16)DriftLevel < CONFIG->limit_drift) {
   1688          							//
   1689          							DeviceFault.fFaultDrift = 1;
   1690          							SetFaultMode();
   1691          							//
   1692          							SetLevels(CONFIG->limit_drift);
   1693          						}else{
   1694          							SetLevels((u16)DriftLevel);
   1695          						}
   1696          						//	
   1697          						ClearDriftVar();
   1698          						//
   1699          					}
   1700          				}
   1701          			}
   1702          			//			
   1703          			//
   1704          label_light:			
   1705          			//
   1706          			BCSCTL1 = CALBC1_1MHZ; 					// Используем частоту 1 MГц
   1707          			DCOCTL =  CALDCO_1MHZ;
   1708          			TA1CCR0  = 1 * SYS_TICK_TIME - 1;   	// Period T(us) * F(MHz)
   1709          			//
   1710          			DelayUs(1);
   1711          			//
   1712          			if (fSendingGraph) {
   1713          				//
   1714          				BCSCTL1 = CALBC1_8MHZ; 					// Используем частоту 8 MГц
   1715          				DCOCTL =  CALDCO_8MHZ;
   1716          				TA1CCR0  = 0xFFFF - 1;   				// ~ Compensation of frequence increase
   1717          				//
   1718          				//
   1719          				for (i = 0; i < SIGNAL_ARRAY_LEN; i++) {
   1720          					signal_array[i] += 350;
   1721          				}
   1722          				
   1723          				loc_buf[0] = Q_SEND_GRAPH2;
   1724          				loc_buf[1] = SIGNAL_ARRAY_LEN * 2;
   1725          				SoftUART_TxString(loc_buf, 2);
   1726          				//
   1727          				SoftUART_TxString((u8*)&signal_array[0], SIGNAL_ARRAY_LEN * 2);
   1728          				
   1729          				SoftUART_TxString((u8*)&delta, 2);
   1730          				
   1731          				fSendingGraph = 0;
   1732          				//
   1733          				BCSCTL1 = CALBC1_1MHZ; 					// Используем частоту 1 MГц
   1734          				DCOCTL =  CALDCO_1MHZ;
   1735          				TA1CCR0  = 1 * SYS_TICK_TIME - 1;   	// Period T(us) * F(MHz)
   1736          				//
   1737          			}
   1738          			//
   1739          			//
   1740          			// Indication
   1741          			//
   1742          			if (DeviceMode == MODE_NORM) {
   1743          				light_timer = 1;				// Value - the light power
   1744          				flash_period_timer = 120;		// Flash after 1.2 sec
   1745          			}
   1746          			//
   1747          			if ((DeviceMode == MODE_PREFIRE) || (DeviceMode == MODE_PREPREFIRE)) {
   1748          				light_timer = 4;				// Value - the light power
   1749          				flash_period_timer = 120;		// Flash after 1.2 sec
   1750          			}
   1751          			//
   1752          			if (DeviceMode == MODE_CALIBR) {
   1753          				light_timer = 7;				// Value - the light power
   1754          				flash_period_timer = 120;		// Flash after 1.2 sec
   1755          			}
   1756          			//
   1757          			if (DeviceMode == MODE_TEST) {
   1758          				// Indication sygnal level
   1759          				LedTestValueManager();			
   1760          				//
   1761          			}
   1762          			//
   1763          			light_sync++;
   1764          			led_timer = 400;	//4 sec
   1765          			
   1766          			STROB_IE_Enable();
   1767          		}
   1768          		
   1769          //-------------------------------------------------------------------------------
   1770          // Strobe StartPulse Event		
   1771          		if (fStartPulse) {			// Start pulse was received
   1772          			fStartPulse = 0;
   1773          			//
   1774          			AMP_PWR_ON();						// AMP Power Supply Enable
   1775          			// Vref Enable
   1776          			if (DeviceMode == MODE_CALIBR) {
   1777          				ADC_MeasureInit(amp_no, reference);
   1778          			}else{
   1779          				ADC_MeasureInit(CONFIG->AMP_No, reference);
   1780          			}
   1781          			
   1782          			//TEST2_SET();
   1783          			
   1784          			_BIC_SR(GIE);    			// Запрещаем прерывания
   1785          			Timer_A0_SetDelay(2250);
   1786          			_BIS_SR(GIE);    			// Разрешаем прерывания
   1787          			//
   1788          			BCSCTL1 = CALBC1_8MHZ; 		// Используем частоту 8 MГц
   1789          			DCOCTL =  CALDCO_8MHZ;
   1790          			//
   1791          			TA1CCR0  = 0xFFFF - 1;   	// ~ Compensation of frequence increase
   1792          			//
   1793          			// For define the presence of strob pulses
   1794          			strob_pulse_timer = 0;
   1795          			DeviceFault.fStrobNone = 0;
   1796          			//
   1797          			fault_phase = 0;
   1798          			fault_timer = 0;
   1799          		}
   1800          		
   1801          
   1802          //-------------------------------------------------------------------------------
   1803          // KEY DOWN event		
   1804          		if (fButtonDownOn) {									// Нажата кнопка
   1805          			fButtonDownOn = 0;
   1806          			//...
   1807          			timerKeyDown = 1;
   1808          			//
   1809          		} // if (fButtonDownOn)
   1810          		
   1811          //-------------------------------------------------------------------------------
   1812          // KEY UP event
   1813          		if (fButtonUpOn) {			// Отжата кнопка
   1814          			fButtonUpOn = 0;
   1815          
   1816          			if ((timerKeyDown > 4) && (timerKeyDown < 150))  {	// < 1.5 sec
   1817          				// The short pressure on the button
   1818          				if ((DeviceMode == MODE_NORM) || (DeviceMode == MODE_PREFIRE) || (DeviceMode == MODE_PREPREFIRE)) {
   1819          					DeviceMode = MODE_TEST;
   1820          					DeviceFault.byte = 0;	// Reset all faults
   1821          					FIRE_SET();				// Set fire mode current consumption
   1822          					RED_CLR();
   1823          					YEL_SET();
   1824          					timerMain = 12000;		// 120 sec
   1825          					led_sh = 0;
   1826          					led_timer = 0;			// Устраняем задержку оптической индикации
   1827          					led_clk = 0xFF;
   1828          				}else
   1829          				//	
   1830          				if (DeviceMode == MODE_TEST) {
   1831          					DeviceMode = MODE_NORM;
   1832          					DeviceFault.byte = 0;	// Reset all faults
   1833          					//led_timer = 0;
   1834          					RED_CLR();
   1835          					YEL_CLR();
   1836          					FIRE_CLR();
   1837          				}else
   1838          				//
   1839          				if (DeviceMode == MODE_FIRE) {
   1840          					DeviceMode = MODE_NORM;
   1841          					DeviceFault.byte = 0;	// Reset all faults
   1842          					RED_CLR();
   1843          					YEL_CLR();
   1844          					FIRE_CLR();				// Disable Fire Mode consumption
   1845          					led_r = 0;
   1846          					led_y = 0;
   1847          				}
   1848          			}
   1849          			//
   1850          			timerKeyDown = 0;
   1851          		} // if (fButtonUpOn) {
   1852          
   1853          		
   1854          //-------------------------------------------------------------------------------
   1855          // Soft UART Rx Hundler
   1856          		if (fRxLineDownOn) {
   1857          			uart_rx_ind = 0;
   1858          			//
   1859          label_rx_continue:
   1860          			fRxLineDownOn = 0;
   1861          			//
   1862          			DelayUs_8MHz(25);		// Delay to center of pulse
   1863          			//
   1864          			//TEST2_SET();
   1865          			//TEST2_CLR();
   1866          			//
   1867          			if ((INTER_BIT & INTER_IN) == 0) {
   1868          				SoftUART_SetReceiveByte();
   1869          				
   1870          			}else{
   1871          				//
   1872          				BCSCTL1 = CALBC1_1MHZ; 					// Используем частоту 1 MГц
   1873          				DCOCTL =  CALDCO_1MHZ;
   1874          				//
   1875          				TA1CCR0  = 1 * SYS_TICK_TIME - 1;   	// Period T(us) * F(MHz)
   1876          				//
   1877          				continue;		// False pulse
   1878          			}
   1879          			sh = 0x01;
   1880          			byte = 0;
   1881          			while (sh) {
   1882          				if (fTimerA_On) {
   1883          					fTimerA_On = 0;
   1884          					//
   1885          					//TEST2_SET();
   1886          					//TEST2_CLR();
   1887          					//
   1888          					if (INTER_BIT & INTER_IN) {
   1889          						byte |= sh;
   1890          					}
   1891          					sh <<= 1;
   1892          				}
   1893          			}
   1894          			// Receive byte
   1895          			SoftUART_ResetReceiveByte();
   1896          			//
   1897          			if (uart_rx_ind == 0) {
   1898          				// Begin of packet
   1899          				len = packet_len_table[byte];
   1900          				if (len > UART_BUF_LEN) {
   1901          					len = UART_BUF_LEN;
   1902          				}
   1903          			}
   1904          				
   1905          			*(uart_rx_buf+uart_rx_ind++) = byte;
   1906          			if (uart_rx_ind >= len) {
   1907          				// Parse of packet
   1908          				//...
   1909          				SoftUART_RxParse();
   1910          				INTER_IFG &= ~INTER_BIT;    				// Обнуляем флаг прерывания
   1911          				fRxLineDownOn = 0;
   1912          			}else{
   1913          				//			
   1914          				uart_timer = 4;								// 200 ms timeout to next byte
   1915          				while (1) {
   1916          					//__bis_SR_register(LPM3_bits + GIE);     // Enter LPM3
   1917          					//
   1918          					while ((fRxLineDownOn || fTimer50msOn) == 0) {}
   1919          					//
   1920          					if (fRxLineDownOn) {
   1921          						goto label_rx_continue;
   1922          					}
   1923          					if (fTimer50msOn) {						// Получен следующий 50мс интервал
   1924          						fTimer50msOn = 0;
   1925          						//
   1926          						if (uart_timer) {
   1927          							uart_timer--;
   1928          						}else{
   1929          							// End of Rx timeout
   1930          							//...
   1931          							INTER_IFG &= ~INTER_BIT;    	// Обнуляем флаг прерывания
   1932          							fRxLineDownOn = 0;
   1933          							break;
   1934          						}
   1935          					}
   1936          				}
   1937          			}
   1938          			//
   1939          			//
   1940          			BCSCTL1 = CALBC1_1MHZ; 					// Используем частоту 1 MГц
   1941          			DCOCTL =  CALDCO_1MHZ;
   1942          			//
   1943          			TA1CCR0  = 1 * SYS_TICK_TIME - 1;   	// Period T(us) * F(MHz)
   1944          			//
   1945          			//
   1946          		} // Soft UART Rx Hundler
   1947          	} // while(1)
   1948          }
   1949          
   1950          
   1951          
   1952          
   1953          //--------------------------------------------------------------------------------
   1954          // Function		: __interrupt void watchdog_timer (void)
   1955          // Parameters	: None
   1956          // Return		: None
   1957          // Description	: WDT Interrupt routine
   1958          //--------------------------------------------------------------------------------
   1959          #pragma vector=WDT_VECTOR
   1960          __interrupt void watchdog_timer (void) {
   1961          	
   1962          	if (fTimer50msOn) {
   1963          		if (++Timer50msCounter == 0) {		// > ~ 12sec
   1964          			WDTCTL = WDTCTL;				// Hardware RESET
   1965          		}
   1966          	}
   1967          	fTimer50msOn = 1;
   1968          	
   1969          	__bic_SR_register_on_exit(LPM3_bits);                   // Clear LPM3 bits from 0(SR)
   1970          }
   1971          
   1972          
   1973          
   1974          //--------------------------------------------------------------------------------
   1975          // Function		: __interrupt void CCR0_ISR(void)
   1976          // Parameters	: None
   1977          // Return		: None
   1978          // Description	: TIMER0 Interrupt routine
   1979          //--------------------------------------------------------------------------------
   1980          #pragma vector = TIMER0_A0_VECTOR
   1981          __interrupt void CCR0_ISR(void) {
   1982          
   1983          	fTimerA_On = 1;
   1984          	
   1985          } // CCR0_ISR
   1986          
   1987          
   1988          
   1989          //--------------------------------------------------------------------------------
   1990          // Function		: __interrupt void Timer_A1_ISR (void)
   1991          // Parameters	: None
   1992          // Return		: None
   1993          // Description	: TIMER1 Interrupt routine
   1994          //--------------------------------------------------------------------------------
   1995          #pragma vector=TIMER1_A0_VECTOR
   1996          __interrupt void Timer_A1_ISR (void)  {
   1997          	
   1998          	fTimerA1_On = 1;
   1999          	//__bic_SR_register_on_exit(LPM0_bits);                   // Clear LPM3 bits from 0(SR)
   2000          } 
   2001          
   2002          
   2003          
   2004          //--------------------------------------------------------------------------------
   2005          // Function		: void Led_Flash(u16 duration)
   2006          // Parameters	: duration - duration Red LED flash in ms
   2007          // Return		: None
   2008          // Description	: Flashing red LED
   2009          //--------------------------------------------------------------------------------
   2010          void Led_Flash(u16 duration) {
   2011          	RED_SET();
   2012          	DelayMs(duration);
   2013          	RED_CLR();
   2014          }
   2015          
   2016          
   2017          
   2018          
   2019          
   2020          //--------------------------------------------------------------------------------
   2021          // Function		: u16 GetVCC(u8 boost_stop)
   2022          // Parameters	: boost_stop = 1 - if need call BoostStop() after measure
   2023          // Return		: Value in 10mV (for example 250 = 2.50V)
   2024          // Description	: Measurement the voltage VCC
   2025          //--------------------------------------------------------------------------------
   2026          u16 GetVCC(u8 boost_stop) {
   2027          	u16 res;	
   2028          	ADC_Measure(ADC_CH_VCC, 0, VCC_DATA_LEN);
   2029          	//~~~
   2030          	VREF_Off();
   2031          	//
   2032          	//	
   2033          	res = AverageData(adc_data1, VCC_DATA_LEN);
   2034          	res = res * 64 / 218 + 2;						//~~res = ((u32)res * 301) / 1024 & Compensation dV(R38)=20mV (max=302)
   2035          	return (res);			
   2036          }
   2037          
   2038          
   2039          
   2040          
   2041          //--------------------------------------------------------------------------------
   2042          // Function		: void VREF_On(void)
   2043          // Parameters	: None 
   2044          // Return		: None
   2045          // Description	: Enable VREF
   2046          //--------------------------------------------------------------------------------
   2047          void VREF_On(void) {
   2048          
   2049          	ADC10CTL0 = REFOUT + REFON + SREF_1 + MSC + ADC10ON;
   2050          	ADC10AE0 |= 0x10;                         // P1.4 ADC option select (VRef Out)
   2051          
   2052          }
   2053          
   2054          
   2055          
   2056          //--------------------------------------------------------------------------------
   2057          // Function		: void VREF_Off(void)
   2058          // Parameters	: None
   2059          // Return		: None
   2060          // Description	: Disable VREF
   2061          //--------------------------------------------------------------------------------
   2062          void VREF_Off(void) {
   2063          
   2064          	ADC10CTL0 = 0;							// Disable ADC & +VREF
   2065          	ADC10CTL0 = 0;							//
   2066          }
   2067          
   2068          
   2069          
   2070          //--------------------------------------------------------------------------------
   2071          // Function		: void ADC10_ISR(void)
   2072          // Parameters	: None
   2073          // Return		: None
   2074          // Description	: ADC10 interrupt service routine
   2075          //--------------------------------------------------------------------------------
   2076          #pragma vector=ADC10_VECTOR
   2077          __interrupt void ADC10_ISR(void) {
   2078          
   2079          	//ADC10AE0 &= ~0x0F;                      // Save only VRef Out
   2080          	
   2081          	adc_process = 0;
   2082          	
   2083          	fEndOfSamples = 1;
   2084          	
   2085          	//__bic_SR_register_on_exit(CPUOFF);      // Clear CPUOFF bit from 0(SR)
   2086          	
   2087          }
   2088          
   2089          
   2090          
   2091          //--------------------------------------------------------------------------------
   2092          // Function		: u16 AverageData(u16 * data_ptr, u8 len)
   2093          // Parameters	: data_ptr - data array pointer, len - length of data array
   2094          // Return		: Average value of data
   2095          // Description	: Fuction calculate the average value of data array
   2096          //--------------------------------------------------------------------------------
   2097          u16 AverageData(u16 * data_ptr, u8 len) {
   2098          	u16 summa = 0;
   2099          	u8  i = len;
   2100          	while (i--) {
   2101          		summa += *data_ptr++;
   2102          	}
   2103          	//
   2104          	return (summa/len);
   2105          }
   2106          
   2107          
   2108          //--------------------------------------------------------------------------------
   2109          // Function		: void DeviceDiagnostics(void)
   2110          // Parameters	: None
   2111          // Return		: None
   2112          // Description	: Procedure of the diagnostics device
   2113          //--------------------------------------------------------------------------------
   2114          void DeviceDiagnostics(void) {
   2115          	//
   2116          	DelayMs(100);
   2117          	//
   2118          	//
   2119          		
   2120          #if (CRC_ENABLE == 1)
   2121          	// Check CS of Memory
   2122          	DeviceFault.fFaultCRC = 0;
   2123          	if (GetPropertiesCS() != CONFIG->CS) {
   2124          		DeviceFault.fFaultCRC = 1;
   2125          	}
   2126          #endif
   2127          }
   2128          
   2129          //--------------------------------------------------------------------------------
   2130          // Function		: u16 ADC_Measure_Simple(u16 ch, u16* buf, u8 count)
   2131          // Parameters	: refout = 0 or REFOUT, vref = REF1_5V , count - кол-во измерений 
   2132          // Return		: None
   2133          // Description	: Measurement of the current temperature of MCU
   2134          //--------------------------------------------------------------------------------
   2135          #pragma optimize=none
   2136          u16 ADC_Measure_Simple(u16 ch, u16* buf, u8 count) {
   2137          	u16 res;
   2138          
   2139          	while(adc_process) {}
   2140          	
   2141          	BUT_IE &= ~BUT_BIT;
   2142          	BUT_REN &= ~BUT_BIT; 		// PULL disable
   2143          	
   2144          	ADC10CTL0 = SREF_0 + ADC10SHT_1 + MSC  + ADC10ON + ADC10IE;	// Sample&hold = 8 x ADC10CLKs
   2145          	
   2146          	DelayUs(50);	
   2147          	//
   2148          	ADC10CTL1 = ADC10SSEL_2 + ADC10DIV_7 + CONSEQ_2 + ch;	// ADC_BUT;     // 
   2149          	//
   2150          	DelayUs(200);							// Delay to allow Ref to settle
   2151          
   2152          	ADC10DTC1 = count;						// count of conversions
   2153          	ADC10AE0 = ADC_AE_BUT;                 // A3 & A7 ADC option select
   2154          	//
   2155          	ADC10SA = (u16) &buf[0];          		// Data buffer start
   2156          	
   2157          	fEndOfSamples = 0;
   2158          	ADC10CTL0 |= ENC + ADC10SC;             // Sampling and conversion start
   2159          		
   2160          	__bis_SR_register(CPUOFF + GIE);        // LPM0, ADC10_ISR will force exit
   2161          	
   2162          	while (fEndOfSamples == 0){};
   2163          	fEndOfSamples = 0;
   2164          
   2165          	res = AverageData(buf, count);	
   2166          
   2167          	ADC10AE0 = ADC_AE;          // A3 & A7 ADC option select
   2168          	
   2169          	BUT_IFG &= ~BUT_BIT;    	// Обнуляем флаг прерывания
   2170          	BUT_IE |= BUT_BIT;
   2171          	BUT_REN |= BUT_BIT; 		// PULL enable
   2172          	
   2173          	return res;
   2174          }
   2175          
   2176          
   2177          //--------------------------------------------------------------------------------
   2178          // Function		: void u8 JP1_Define(void)
   2179          // Parameters	: None
   2180          // Return		: 0 - JP1 Open, 1 - JP1 Close
   2181          // Description	: Definition of JP1 state
   2182          //--------------------------------------------------------------------------------
   2183          void JP1_Define(void) {
   2184          	u16 buf[4];
   2185          	u16 res;
   2186          	
   2187          	res = ADC_Measure_Simple(ADC_BUT, buf, 4);
   2188          	
   2189          	if (res > 600) return; 
   2190          	if (res > 100) {
   2191          		jp1_state = 0;		// JP1 is Open 
   2192          	}else{
   2193          		jp1_state = 1;		// JP1 is Close
   2194          	}	
   2195          	//
   2196          	return;	
   2197          }
   2198          
   2199          
   2200          // End of main.c

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   ADC10_ISR
      4   ADC_MeasureInit
        6   -> DelayUs
      0   ADC_MeasureStart
     10   ADC_Measure_Simple
       10   -> AverageData
       10   -> DelayUs
       10 ?Epilogue4
      0   ADC_SetParam
      2   AMP_Gain_Init
        0   -> AMP_SetGain
      2   AbsValue
      2   AverageData
        0 ?DivMod16u
      4   CCR0_ISR
     22   CalibrationResultAnalise
       22   -> AMP_SetGain
       22   -> SetLevelsFromCalibr
       22   -> SetLimitCompens
       22   -> StoragePropertyByte
       22   -> StoragePropertyWord
       14 ?Epilogue6
      2   ClearDriftVar
      2   DefineNewMode
      2   DeviceDiagnostics
        2   -> DelayMs
        2   -> GetPropertiesCS
      2   DeviceStart
        4   -> SavePropertyCS
        6   -> StoragePropertyWord
      2   FaultSignalManager
      2   GetVCC
        2   -> ADC_Measure
        2 ?DivMod16u
     10   JP1_Define
       10   -> ADC_Measure_Simple
      2   LedTestValueManager
      2   Led_Flash
        2   -> DelayMs
      0   SetFaultMode
      6   SetLevels
        8   -> SavePropertyCS
       10   -> StoragePropertyWord
        6   -> StoragePropertyWord
        6 ?DivMod16s
        6 ?DivMod16u
      6   SetLevelsFromCalibr
        8   -> SavePropertyCS
       10   -> StoragePropertyWord
        6   -> StoragePropertyWord
        6 ?DivMod16s
        6 ?DivMod16u
      2   SetLimitCompens
        2   -> SavePropertyCS
        4   -> StoragePropertyWord
     34   SignalAnalysis
       30 ?DivMod16s
       30 ?DivMod32s
       14 ?Epilogue6
       34 ?Mul16to32s
      2   TimerA1_DelayUs
      0   Timer_A0_Off
      2   Timer_A0_SetDelay
      4   Timer_A1_ISR
      0   Timer_A1_Init
      2   VLO_GetPeriod
      0   VLO_TimerCalibr
        2   -> SavePropertyCS
        4   -> StoragePropertyWord
      2   VREF_Off
      2   VREF_On
     10   fir_filter
       10 ?DivMod32s
       10 ?Epilogue4
       10 ?Mul16to32s
      2   getZeroLevel
        0 ?DivMod16u
     18   main
       18   -> ADC_Measure_Simple
       18   -> AMP_SetGain
       18   -> CalibrationResultAnalise
       18   -> DelayMs
       20   -> DelayMs
       18   -> DelayUs
       20   -> DelayUs
       18   -> DelayUs_8MHz
       18   -> FaultSignalManager
       18   -> GPIO_Init
       18   -> STROB_IE_Enable
       20   -> SavePropertyCS
       18   -> SignalAnalysis
       18   -> SoftUART_ResetReceiveByte
       18   -> SoftUART_RxParse
       18   -> SoftUART_SetReceiveByte
       18   -> SoftUART_TxString
       20   -> SoftUART_TxString
       18   -> StoragePropertyWord
       22   -> StoragePropertyWord
       18   -> VLO_TimerCalibr
       18 ?DivMod16s
       18 ?DivMod16u
       20 ?DivMod16u
       18 ?DivMod32u
      4   watchdog_timer


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       8  ??Subroutine40_0
       6  ??Subroutine41_0
      22  ??Subroutine4_0
      38  ?Subroutine0
      12  ?Subroutine10
      10  ?Subroutine11
      18  ?Subroutine12
      16  ?Subroutine13
       4  ?Subroutine14
      24  ?Subroutine15
      16  ?Subroutine16
      10  ?Subroutine17
      10  ?Subroutine18
      28  ?Subroutine19
      64  ?Subroutine2
      20  ?Subroutine20
      18  ?Subroutine21
      14  ?Subroutine22
      36  ?Subroutine23
      18  ?Subroutine24
      10  ?Subroutine25
      16  ?Subroutine26
      10  ?Subroutine28
      24  ?Subroutine3
      20  ?Subroutine30
      28  ?Subroutine31
       8  ?Subroutine32
      14  ?Subroutine33
       8  ?Subroutine34
      16  ?Subroutine35
       8  ?Subroutine36
       6  ?Subroutine37
       8  ?Subroutine38
       8  ?Subroutine39
       8  ?Subroutine4
       2  ?Subroutine5
      12  ?Subroutine6
      12  ?Subroutine7
      16  ?Subroutine8
      18  ?Subroutine9
       1  ADC10AE0
       2  ADC10CTL0
       2  ADC10CTL1
       1  ADC10DTC1
       2  ADC10SA
      10  ADC10_ISR
       2  ADC10_ISR::??INTVEC 10
      58  ADC_MeasureInit
       0  ADC_MeasureStart
     140  ADC_Measure_Simple
       0  ADC_SetParam
       8  AMP_Gain_Init
      14  AbsValue
      22  AverageData
       1  BCSCTL1
       1  BCSCTL3
       1  CALBC1_16MHZ
       1  CALBC1_1MHZ
       1  CALBC1_8MHZ
       1  CALDCO_16MHZ
       1  CALDCO_1MHZ
       1  CALDCO_8MHZ
       4  CCR0_ISR
       2  CCR0_ISR::??INTVEC 18
       2  CCR1_Value
       1  CalibrFault
     416  CalibrationResultAnalise
       4  ClearDriftVar
       1  DCOCTL
       4  DefineNewMode
      32  DeviceDiagnostics
       1  DeviceFault
       1  DeviceMode
      12  DeviceStart
       2  DriftCounter
       4  DriftLevel
       4  DriftSumma
      18  FIRCoef
     258  FaultSignalManager
       1  FireMeasCount
      74  GetVCC
       1  IE1
       1  IFG1
      36  JP1_Define
      88  LedTestValueManager
       8  Led_Flash
       1  P1IE
       1  P1IFG
       1  P1OUT
       1  P1REN
       1  P2DIR
       1  P2IFG
       1  P2IN
       1  P2OUT
       0  SetFaultMode
      22  SetLevels
      64  SetLevelsFromCalibr
      20  SetLimitCompens
     690  SignalAnalysis
       2  TA0CCR0
       2  TA0CCTL0
       2  TA0CCTL1
       2  TA0CTL
       2  TA0R
       2  TA1CCR0
       2  TA1CCTL0
       2  TA1CTL
       2  TA1R
       1  Timer50msCounter
      40  TimerA1_DelayUs
       0  Timer_A0_Off
      24  Timer_A0_SetDelay
       6  Timer_A1_ISR
       2  Timer_A1_ISR::??INTVEC 26
       0  Timer_A1_Init
      30  VLO_GetPeriod
       0  VLO_TimerCalibr
      10  VREF_Off
      14  VREF_On
       2  WDTCTL
      32  adc_data1
       1  adc_process
       1  amp_no
      18  calibr_sequence
       1  calibr_stage
       2  cfg_reg
       2  d1
       2  d2
       2  d3
       2  d4
       2  dark
       2  delta
       2  delta_last
       2  f
       1  fTimerA1_On
       1  fault_chain_ind
       2  fault_chain_timer
       1  fault_chamber_counter
       1  fault_phase
       8  fault_sequence
       2  fault_timer
     112  fir_filter
       2  flash_period_timer
       1  gain
      12  getZeroLevel
       2  hi_signal_counter
       1  jp1_state
       2  last_0_level
       2  last_level
       4  led_r
       4  led_sh
       4  led_y
       1  light_sync
       2  light_timer
    2304  main
       2  mainPeriodCounter
       6  q_array
       1  reference
      12  s_array
     200  signal_array
       2  start_timer
       1  strob_fault_phase
       2  strob_pulse_timer
       2  timerKeyDown
       2  timerLongPeriod
       2  timerMain
      26  watchdog_timer
       2  watchdog_timer::??INTVEC 20
      36  x
       2  zero_timer

 
 5 206 bytes in segment CODE
    47 bytes in segment DATA16_AN
    44 bytes in segment DATA16_C
   371 bytes in segment DATA16_Z
     8 bytes in segment INTVEC
     2 bytes in segment REGVAR_AN
 
 5 206 bytes of CODE     memory
    44 bytes of CONST    memory (+  8 bytes shared)
   371 bytes of DATA     memory (+ 47 bytes shared)
     0 bytes of REGISTER memory (+  2 bytes shared)

Errors: none
Warnings: 7
