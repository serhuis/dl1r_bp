###############################################################################
#
# IAR C/C++ Compiler V6.40.1.950/W32 for MSP430           27/Mar/2017  15:47:39
# Copyright 1996-2015 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for Texas Instruments MSP430
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  regvar
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430
#    Source file   =  E:\_ARTON_PROJ\Arton-DL1-R\BP\soft\git\main.c
#    Command line  =  
#        E:\_ARTON_PROJ\Arton-DL1-R\BP\soft\git\main.c -lcN
#        E:\_ARTON_PROJ\Arton-DL1-R\BP\soft\git\IAR\Debug\List -o
#        E:\_ARTON_PROJ\Arton-DL1-R\BP\soft\git\IAR\Debug\Obj --debug
#        -D__MSP430G2433__ -e --double=32 --regvar_r4 --dlib_config "C:\Program
#        Files (x86)\IAR Systems\Embedded Workbench 7.3\430\lib\dlib\dl430fn.h"
#        -I ..\ -I .\ -Oh
#    List file     =  
#        E:\_ARTON_PROJ\Arton-DL1-R\BP\soft\git\IAR\Debug\List\main.lst
#    Object file   =  
#        E:\_ARTON_PROJ\Arton-DL1-R\BP\soft\git\IAR\Debug\Obj\main.r43
#
###############################################################################

E:\_ARTON_PROJ\Arton-DL1-R\BP\soft\git\main.c
      1          /**********************************************************************************
      2           *
      3           *      ASD-10QR MAIN routine
      4           * 
      5           **********************************************************************************
      6           * FileName:        main.c
      7           * Version:			1.00
      8           *
      9           * Processor:       MSP430G2xxx
     10           * Complier:        IAR Workbench for MSP430 v4.50 or higher
     11           *                  
     12           * Company:         ARTON
     13           *
     14           * Software License Agreement
     15           *
     16           * The software supplied herewith by ARTON Incorporated
     17           * (the "Company") for its devices is intended and
     18           * supplied to you, the Company's customer, for use solely and
     19           * exclusively on ARTON Inc products. The
     20           * software is owned by the Company and/or its Author, and is
     21           * protected under applicable copyright laws. All rights are reserved.
     22           * Any use in violation of the foregoing restrictions may subject the
     23           * user to criminal sanctions under applicable laws, as well as to
     24           * civil liability for the breach of the terms and conditions of this
     25           * license.
     26           *
     27           * THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES,
     28           * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
     29           * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
     30           * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
     31           * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
     32           * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
     33           *
     34           *
     35           * Author               Date      	Version	  		Comment
     36           *--------------------------------------------------------------------------------
     37           * Oleg Semeniuk	 16.01.2014    	1.00		Release for v1.00
     38           *
     39           *********************************************************************************/
     40          
     41          
     42          /*********************************************************************************/
     43          /*                                 INCLUDES                                      */
     44          /*********************************************************************************/
     45          
     46          
     47          #include <stdio.h>                    /* standard I/O .h-file                */
     48          #include <string.h>                   /* string and memory functions         */
     49          
     50          #include  "hardware.h"
     51          #include  "main.h"
     52          #include  "flash.h"
     53          #include  "type.h"
     54          #include  "delay.h"
     55          #include  "soft_uart.h"
     56          
     57          
     58          /*********************************************************************************/
     59          /*                                 VARIABLES                                     */
     60          /*********************************************************************************/
     61          
     62          __regvar __no_init tFlags 	f 	 @ __R4; 	// Set of state machine flags
     63          
     64          //
     65          u16		timerMain;					// Текущее значение главного таймера
     66          u16		timerLongPeriod;			// Таймер для режимa HUSH
     67          u16		mainPeriodCounter;			// Counter of main time period
     68          u16 	timerKeyDown;				// Для отслеживания нажатия на кнопку TEST
     69          u16		adc_data1[ADC_CH_DATA_LEN];	// Array for ADC samples
     70          
     71          u8 		DeviceMode; 				// Mode of device
     72          
     73          tFault	DeviceFault = {0};			// Current Faults flags
     74          tCalibrFault CalibrFault = {0};		// Calibration Faults flags
     75          u16 	dark;						// Level of dark signal
     76          u16 	delta;						// Current level signal
     77          
     78          u16 	delta_last = 0;				// Prev sygnal of delta
     79          u16		zero_timer = 0;				// Zero level signal timer
     80          
     81          u8		fault_chamber_counter = 0;	// Counter of series chamber fault
     82          u8  	FireMeasCount = 0;			// Количество замеров, превышающих порог Пожара
     83          
     84          // Variables for definition Long Term Drift
     85          u16  	DriftCounter = 0;
     86          u32 	DriftSumma = 0;
     87          u32 	DriftLevel;					// Current Long Term Drift Level
     88          	
     89          //u16 	FireLimit;					// Current Limit of Fire
     90          //u16 	PreFireLimit;				// Current Limit of PreFire
     91          	
     92          u16		CCR1_Value;					// CCR1 PWM duty cycle for sound generation
     93          u8 		Timer50msCounter = 0;		// Counter of 50ms ticks
     94          
     95          
     96          s16		signal_array[SIGNAL_ARRAY_LEN];
     97          
     98          //u8		AMP_Off_Timer = 0;
     99          
    100          
    101          volatile u32		led_r;
    102          volatile u32		led_y;
    103          volatile u32		led_sh = 0;
    104          
    105          u8 		fTimerA1_On = 0;
    106          
    107          
    108          #define CALIBR_STAGES		6
    109          u8 		calibr_stage;
    110          u16		s_array[CALIBR_STAGES];
    111          u8		q_array[CALIBR_STAGES];
    112          
    113          /* Old
    114          const u8 calibr_sequence[CALIBR_STAGES][3] = {
    115          //			 Amp_No	Gain  Reference
    116          			{  2,    3,     0 },
    117          			{  2,    3,     1 },
    118          			{  2,    2,     1 },
    119          			{  2,    1,     1 },
    120          			{  2,    0,     1 },
    121          			{  1,    0,     1 },
    122          			{  1,    0,     2 },
    123          };
    124          */
    125          
    126          const u8 calibr_sequence[CALIBR_STAGES][3] = {
    127          //			 Amp_No	Gain  Reference
    128          			{  1,    0,     2 },
    129          			//{  1,    0,     1 },
    130          			{  2,    0,     1 },
    131          			{  2,    1,     1 },
    132          			{  2,    2,     1 },
    133          			{  2,    3,     1 },
    134          			{  2,    3,     0 },
    135          };
    136          
    137          
    138          const u8 fault_sequence[4 * 2] = {MODE_FAULT, 10, MODE_NORM, 10, MODE_FIRE, 0, 0};	// 0 = ~~
    139          
    140          u8  fault_chain_ind = 0;	// 	
    141          u16 fault_chain_timer = 0;
    142          
    143          s8	gain;
    144          u8	amp_no;
    145          u8	reference;
    146          tCfgReg	cfg_reg;
    147          
    148          u8	jp1_state = 0;			// 0 - JP1 Open, 1 - JP1 Close
    149          
    150          u8	adc_process = 0;		// ADC low level semafore
    151          
    152          u16	light_timer = 0;		// For led lighting
    153          u8	light_sync = 0;			// For led lighting syncronisation
    154          
    155          u16	strob_pulse_timer = 0;	// Таймер ожидания электрической синхронизации
    156          u8	strob_fault_phase = 0;	// Фаза неисправности электрической синхронизации 0 - отключение БИ, 1 - включение БИ
    157          
    158          u16	hi_signal_counter  = 0;	// Very Hight signal counter
    159          
    160          u16	fault_timer = 0;		// Fault signal timer
    161          u8  fault_phase  = 0;		// Phase of  fault signal: 1 - break of BI , 0 - enable of  BI	
    162          
    163          u16 start_timer = 0;		// Start timer of device
    164          
    165          u16 flash_period_timer;		// Flast period timer
    166          
    167          
    168          
    169          
    170          
    171          /*********************************************************************************/
    172          /*                                FUNCTIONS                                      */
    173          /*********************************************************************************/
    174          // --- Declarations ---
    175          void ADC_MeasureInit(u8 input_no, u8 refer);
    176          u8   SignalAnalysis(void);
    177          void ADC_MeasureStart(void);
    178          void AMP_Calibration(void);
    179          
    180          u16  AverageData(u16 * data_ptr, u8 len);
    181          void SetRemoteAlarmMode(u8 sound);
    182          u8   RX_PacketParser(void);
    183          void ADC_Measure(u16 ch, u16 refout, u8 count);
    184          void ADC_Measure_TEMP(u16 ch, u16 refout, u8 count);
    185          
    186          void Timer_A1_Init(void);
    187          void Timer_A0_SetDelay(u16 period);
    188          void TimerA1_DelayUs(u16 time);
    189          void Timer_A0_Off(void);
    190          void JP1_Define(void);
    191          
    192          
    193          
    194          
    195          //--------------------------------------------------------------------------------
    196          // Function		: void VLO_TimerCalibr(void)
    197          // Parameters	: None
    198          // Return		: None
    199          // Description	: Calculation calibration value of VLO timer
    200          //--------------------------------------------------------------------------------
    201          void VLO_TimerCalibr(void) {
    202          	u16 clk;
    203          	
    204          	// Start timer 1MHz
    205          	TACTL = TASSEL_2 + MC_1 + ID_3;     	 	// SMCLK, up mode  / 8
    206          	//			
    207          	CCR0 = 62500 - 1;	                    // Period 0.5sec
    208          	CCTL1 = 0; 			                    // CCR1 reset/set
    209          	TACCTL0 = CCIE;							// Разрешаем прерывание таймера по достижению значения TACCCR0.
    210          	//
    211          	clk = 0;
    212          	while (1) {
    213          		if (fTimer50msOn) {
    214          			fTimer50msOn = 0;
    215          			clk++;
    216          		}
    217          		if (fTimerA_On) {
    218          			fTimerA_On = 0;
    219          			clk++;
    220          			break;
    221          		}
    222          	}
    223          	//
    224          	//SoundStop();							// Disable interrupts of timer
    225          	TACTL = 0;  
    226          	TACCTL0 = 0;				// Запрещаем прерывание таймера по достижению значения TACCCR0.
    227          	//
    228          	if (clk != CONFIG->timer_calibr) {
    229          		StoragePropertyWord(eeTIMER_CALIBR_OFFSET, clk * 2);
    230          		#if (CRC_ENABLE == 1)
    231          		SavePropertyCS();
    232          		#endif
    233          	}
    234          	//
    235          }
    236          
    237          
    238          //--------------------------------------------------------------------------------
    239          // Function		: void ClearDriftVar(void)
    240          // Parameters	: None
    241          // Return		: None
    242          // Description	: Clear Long Term Drift variables
    243          //--------------------------------------------------------------------------------
    244          void ClearDriftVar(void) {
    245          	DriftCounter = 0;
    246          	DriftSumma = 0;
    247          	DriftLevel = 0;
    248          }
    249          
    250          
    251          
    252          //--------------------------------------------------------------------------------
    253          // Function		: void SetLimitCompens(void)
    254          // Parameters	: fire_level - fire level in increment
    255          // Return		: None
    256          // Description	: Setting limit compensation level
    257          //--------------------------------------------------------------------------------
    258          void SetLimitCompens(void) {
    259          	u16 norm = CONFIG->limit_norm;
    260          	//
    261          	StoragePropertyWord(eeLIMIT_LONG_DRIFT_OFFSET, norm / 2);
    262          	//
    263          #if (CRC_ENABLE == 1)
    264          	SavePropertyCS();
    265          #endif
    266          	//
    267          	ClearDriftVar();
    268          	//
    269          }
    270          
    271          
    272          
    273          //--------------------------------------------------------------------------------
    274          // Function		: void SetLevels(u16 norm)
    275          // Parameters	: norm - norm sygnal level 
    276          // Return		: None
    277          // Description	: Calculation and setting levels depending on background signal
    278          //--------------------------------------------------------------------------------
    279          void SetLevels(u16 norm) {
    280          	u16 temp;
    281          	u8  d;	
    282          	StoragePropertyWord(eeLIMIT_NORM_OFFSET, norm);
    283          	//
    284          	d = norm * 28 / 100;
    285          	//
    286          	temp = norm - d;		//
    287          	StoragePropertyWord(eeLIMIT_FIRE_OFFSET, temp);
    288          	//
    289          	temp = norm - d * 3 / 4;		//
    290          	StoragePropertyWord(eeLIMIT_PREFIRE_OFFSET, temp);
    291          	
    292          	//
    293          #if (CRC_ENABLE == 1)
    294          	SavePropertyCS();
    295          #endif
    296          	//
    297          	ClearDriftVar();
    298          	//
    299          }
    300          
    301          
    302          
    303          //--------------------------------------------------------------------------------
    304          // Function		: void SetLevels(u16 norm)
    305          // Parameters	: norm - norm sygnal level, nonlinearity_corr - correction 
    306          //				  nonlinearity in case of Hi signal (0 - none, 1 - low correction,
    307          //				  2 - hi correction)
    308          // Return		: None
    309          // Description	: Calculation and setting levels depending on background signal
    310          //--------------------------------------------------------------------------------
    311          void SetLevelsFromCalibr(u16 norm, u8 nonlinearity_corr) {
    312          	u16 temp;
    313          	u8  d;	
    314          	StoragePropertyWord(eeLIMIT_NORM_OFFSET, norm);
    315          	//
    316          	switch (nonlinearity_corr) {
    317          		case 0:
    318          			d = norm * 29 / 100;
    319          			break;
    320          		case 1:
    321          			d = norm * 23 / 100;
    322          			break;
    323          		case 2:
    324          			d = norm * 18 / 100;
    325          			break;
    326          		default:
    327          			d = norm * 29 / 100;
    328          	}
    329          	//
    330          	temp = norm - d;		//
    331          	StoragePropertyWord(eeLIMIT_FIRE_OFFSET, temp);
    332          	//
    333          	temp = norm - d * 3 / 4;		//
    334          	StoragePropertyWord(eeLIMIT_PREFIRE_OFFSET, temp);
    335          	
    336          	//
    337          #if (CRC_ENABLE == 1)
    338          	SavePropertyCS();
    339          #endif
    340          	//
    341          	ClearDriftVar();
    342          	//
    343          }
    344          
    345          
    346          
    347          //--------------------------------------------------------------------------------
    348          // Function		: void DeviceStart(void)
    349          // Parameters	: None
    350          // Return		: None
    351          // Description	: Function executes initialization variable at start of device
    352          //--------------------------------------------------------------------------------
    353          void DeviceStart(void) {
    354          
    355          	DeviceFault.byte = 0;		// Reset faults flags
    356          	CalibrFault.byte = 0;		// Reset faults flags
    357          	//		
    358          	VLO_TimerCalibr();			// Calibration VLO Timer
    359          	//
    360          	ClearDriftVar();
    361          	
    362          }
    363          
    364          
    365          //--------------------------------------------------------------------------------
    366          // Function		: void DefineFireLimit(void)
    367          // Parameters	: None
    368          // Return		: None
    369          // Description	: Determination fire and prefire limits depending on long term drift
    370          //--------------------------------------------------------------------------------
    371          //#pragma optimize=none
    372          u16 getZeroLevel(void) {
    373          	u16 ret;
    374          	//
    375          	ret = CONFIG->limit_norm / 6;
    376          	return ret;
    377          }
    378          
    379          
    380          //--------------------------------------------------------------------------------
    381          // Function		: u16 getTimerValue(u16 period_sec)
    382          // Parameters	: time_sec : time in sec (0..655)
    383          // Return		: None
    384          // Description	: Getting time in system ticks
    385          //--------------------------------------------------------------------------------
    386          static u16 getTimerValue(u16 time_sec) {
    387          	u16 time = 100;
    388          	
    389          	if (time_sec > 655) return 0;
    390          	
    391          	time *= time_sec;	
    392          	
    393          	return time;
    394          
    395          }
    396          
    397          
    398          //--------------------------------------------------------------------------------
    399          // Function		: void VLO_TimerCalibr(void)
    400          // Parameters	: None
    401          // Return		: None
    402          // Description	: Calculation calibration value of VLO timer
    403          //--------------------------------------------------------------------------------
    404          u16 VLO_GetPeriod(void) {
    405          	
    406          	// Start timer 8MHz
    407          	TACTL = TASSEL_2 + MC_1;           	 	// SMCLK, up mode
    408          	//			
    409          	CCR0 =0xFFFF;                    		// Period 2.5mS
    410          	CCTL1 = 0; 			                    // CCR1 reset/set
    411          	TACCTL0 = 0;							// Разрешаем прерывание таймера по достижению значения TACCCR0.
    412          	//
    413          	while (fTimer50msOn == 0) {}
    414          	fTimer50msOn = 0;
    415          	//while (fTimer50msOn == 0) {}
    416          	
    417          	return TAR;
    418          	
    419          }
    420          
    421          
    422          //--------------------------------------------------------------------------------
    423          // Function		: void VLO_TimerCalibr(void)
    424          // Parameters	: None
    425          // Return		: None
    426          // Description	: Calculation calibration value of VLO timer
    427          //--------------------------------------------------------------------------------
    428          void AMP_Gain_Init(void) {
    429          	
    430          	AMP_SetGain(CONFIG->Gain);
    431          	
    432          }
    433          
    434          #define ADC_AMP1	INCH_1		/* First AMP out */
    435          #define ADC_AMP2	INCH_0		/* Second AMP out */
    436          #define ADC_BUT		INCH_2		/* Tact button */
    437          #define ADC_AE		0x13		/* Analog (Input) Enable Control Register Value + VREF+*/
    438          #define ADC_AE_BUT	0x17		/* Analog (Input) Enable Control Register Value + Tact sw + VREF+*/
    439          
    440          #define ADC_FLUCTATION			20
    441          #define SIGNAL_0_LEVEL			512
    442          
    443          #define CORREL_LEVEL			120		/* Threshold level to correlations of the start signal */
    444          
    445          
    446          
    447          //--------------------------------------------------------------------------------
    448          // Function		: ADC_Measure(u8 input_no, u8 refer)
    449          // Parameters	: input_no - number AMP output (= 1 or 2), refer - reference voltage (=0 - 1.5V, =1 - 2.5V, =2 - 3.3V)
    450          // Return		: None
    451          // Description	: Функция производит измерения по выбранному каналу ADC и помещает их в массив adc_data1
    452          //				   ~109 kS/s for 16 MHz 
    453          //--------------------------------------------------------------------------------
    454          void ADC_MeasureInit(u8 input_no, u8 refer) {
    455          	
    456          	ADC10CTL0 &= ~ENC;
    457          	while (ADC10CTL1 & BUSY);             	// Wait if ADC10 core is active 
    458          	//
    459          	switch ((Ref_Type)refer) {
    460          		case REF_1_5V:  
    461          			ADC10CTL0 = SREF_1 + ADC10SHT_1 + MSC + REFOUT + REFON + ADC10ON + ADC10IE;				// Sample&hold = 8 x ADC10CLKs
    462          			break;
    463          		case REF_2_5V:  
    464          			ADC10CTL0 = SREF_1 + ADC10SHT_1 + MSC + REFOUT + REFON + ADC10ON + ADC10IE + REF2_5V;	// Sample&hold = 8 x ADC10CLKs
    465          			break;
    466          		case REF_3_3V:  
    467          			ADC10CTL0 = SREF_0 + ADC10SHT_1 + MSC + ADC10ON + ADC10IE  + REFOUT + REFON + REF2_5V;	// Sample&hold = 8 x ADC10CLKs
    468          			break;
    469          	}
    470          	//
    471          	DelayUs(50);	
    472          	//
    473          	ADC10DTC1 = SIGNAL_ARRAY_LEN;	//ADC_SAMPLES_NUMBER;			// count of conversions
    474          	//
    475          	if (input_no == 1) {
    476          		ADC10CTL1 = ADC10SSEL_2 + ADC10DIV_7 + CONSEQ_2 + ADC_AMP1;     // MCLK + ADC10 Clock Divider Select 6 (DIV = 7),  Input 1
    477          	}else{
    478          		ADC10CTL1 = ADC10SSEL_2 + ADC10DIV_7 + CONSEQ_2 + ADC_AMP2;     // MCLK + ADC10 Clock Divider Select 6 (DIV = 7),  Input 2
    479          	}
    480          	
    481          	ADC10AE0 |= ADC_AE;                     // A0 & A1 ADC option select
    482          	//
    483          }
    484          
    485          
    486          //--------------------------------------------------------------------------------
    487          // Function		: ADC_Measure(u16 ch, u16 refout, u8 count)
    488          // Parameters	: ch - ADC channel, refout - 0 or REFOUT, count - кол-во измерений 
    489          // Return		: None
    490          // Description	: Функция производит измерения по выбранному каналу ADC и помещает их в массив adc_data1
    491          //--------------------------------------------------------------------------------
    492          void ADC_MeasureStart(void) {
    493          	__disable_interrupt();		// Disable interrupt
    494          	
    495          	adc_process = 1;
    496          	
    497          	//ADC10SA = (u16) &signal_array[SIGNAL_ARRAY_LEN - ADC_SAMPLES_NUMBER];      	// Data buffer start - end of sygnal_array
    498          	ADC10SA = (u16) &signal_array[0];	// Data buffer start - end of sygnal_array
    499          	ADC10CTL0 |= ENC + ADC10SC;         // Sampling and conversion start
    500          	//
    501          	
    502          	__enable_interrupt();                     // enable interrupts
    503          }
    504          
    505          
    506          
    507          u16 last_0_level;
    508          u16 last_level;
    509          
    510          //--------------------------------------------------------------------------------
    511          // Function		: void VLO_TimerCalibr(void)
    512          // Parameters	: None
    513          // Return		: 0 - no valid array, 1
    514          // Description	: The analysis of the input signal on ADC_SAMPLES_NUMBER samples
    515          //--------------------------------------------------------------------------------
    516          u16 AbsValue(u16 x1, u16 x2) {
    517          	if (x1 >= x2) {
    518          		return (x1 - x2);
    519          	}else{
    520          		return (x2 - x1);
    521          	}
    522          }
    523          
    524          /**************************************************************
    525          WinFilter version 0.8
    526          http://www.winfilter.20m.com
    527          akundert@hotmail.com
    528          
    529          Filter type: Band Pass
    530          Filter model: Butterworth
    531          Filter order: 8
    532          Sampling Frequency: 109 KHz
    533          Fc1 and Fc2 Frequencies: 3.800000 KHz and 14.000000 KHz
    534          Coefficents Quantization: 8-bit
    535          
    536          Z domain Zeros
    537          z = -1.000000 + j 0.000000
    538          z = -1.000000 + j 0.000000
    539          z = -1.000000 + j 0.000000
    540          z = -1.000000 + j 0.000000
    541          z = -1.000000 + j 0.000000
    542          z = -1.000000 + j 0.000000
    543          z = -1.000000 + j 0.000000
    544          z = -1.000000 + j 0.000000
    545          z = 1.000000 + j 0.000000
    546          z = 1.000000 + j 0.000000
    547          z = 1.000000 + j 0.000000
    548          z = 1.000000 + j 0.000000
    549          z = 1.000000 + j 0.000000
    550          z = 1.000000 + j 0.000000
    551          z = 1.000000 + j 0.000000
    552          z = 1.000000 + j 0.000000
    553          
    554          Z domain Poles
    555          z = 0.644814 + j -0.260807
    556          z = 0.644814 + j 0.260807
    557          z = 0.756494 + j -0.196546
    558          z = 0.756494 + j 0.196546
    559          z = 0.587475 + j -0.386644
    560          z = 0.587475 + j 0.386644
    561          z = 0.840396 + j -0.195195
    562          z = 0.840396 + j 0.195195
    563          z = 0.588237 + j -0.523443
    564          z = 0.588237 + j 0.523443
    565          z = 0.901607 + j -0.202202
    566          z = 0.901607 + j 0.202202
    567          z = 0.951542 + j -0.212108
    568          z = 0.951542 + j 0.212108
    569          z = 0.642148 + j -0.658914
    570          z = 0.642148 + j 0.658914
    571          ***************************************************************/
    572          
    573          #define Ntap 18
    574          
    575          // !!! See division by DCgain below
    576          #define DCgain 512	
    577          
    578          //const s16 FIRCoef[Ntap] = { 
    579          const s8 FIRCoef[Ntap] = { 
    580                    -13,
    581                    -32,
    582                    -52,
    583                    -59,
    584                    -43,
    585                     -2,
    586                     50,
    587                     95,
    588                    113,
    589                     95,
    590                     50,
    591                     -2,
    592                    -43,
    593                    -59,
    594                    -52,
    595                    -32,
    596                    -13,
    597                     -3
    598          };
    599          
    600          
    601          static s16 	x[Ntap] = {0};	//, 512, 512, 512 }; 	//input samples
    602          
    603          s16 fir_filter(s16 sample) {
    604              s32	 		y = 0;      //output sample
    605              int 		i;
    606          	
    607              // Shift the old samples
    608              for(i = Ntap-1; i > 0; i--) {
    609          		x[i] = x[i-1];
    610          	}
    611          	
    612              // Calculate the new output
    613              x[0] = sample;
    614              for(i = 0; i < Ntap; i++) {
    615          		y += (s32)FIRCoef[i] * x[i];
    616          	}
    617          	
    618          	if (y >= 0) {
    619          		y = y >> 9;
    620          	}else{
    621          		y = y / DCgain;	
    622          	}
    623          	
    624              return y;	// / DCgain;
    625          }
    626          
    627          
    628          
    629          
    630          //--------------------------------------------------------------------------------
    631          // Function		: void VLO_TimerCalibr(void)
    632          // Parameters	: None
    633          // Return		: 0 - no signal, 1 - signal is existing
    634          // Description	: The analysis of the input signal on ADC_SAMPLES_NUMBER samples
    635          //--------------------------------------------------------------------------------
    636          u8 DefineNewMode(u16 delta) {
    637          	
    638          	return 0;
    639          }
    640          
    641          
    642          //s16	adc_back1[ADC_SAMPLES_NUMBER];
    643          
    644          volatile s16	d1, d2, d3, d4;
    645          
    646          #define EXT_ARRAY_LEN	7
    647          
    648          //--------------------------------------------------------------------------------
    649          // Function		: u8 SignalAnalysis(void)
    650          // Parameters	: None
    651          // Return		: 0 - no signal, 1 - signal is existing
    652          // Description	: The analysis of the input signal on ADC_SAMPLES_NUMBER samples
    653          //--------------------------------------------------------------------------------
    654          //#pragma optimize=none
    655          u8 SignalAnalysis(void) {
    656          	int i;
    657          	s16	sample;
    658          	s16 min = 2048, max = -2048;
    659          	int i_min = 0, i_max = 0;
    660          	u8 array_hi[EXT_ARRAY_LEN];
    661          	u8 array_lo[EXT_ARRAY_LEN];
    662          	u8 i_hi = 0;
    663          	u8 i_lo = 0;
    664          	s8 T = 0;
    665          	u8 ret = 0;
    666          	
    667          	// 
    668              for(i = 1; i < Ntap; i++) {
    669          		x[i] = 0;	//signal_array[i] - 220;
    670          	}
    671          	
    672          	sample = AverageData((u16 *)&signal_array[0], 16);
    673          	
    674          	// Filtering with use FIR
    675          	for (i = 0; i < SIGNAL_ARRAY_LEN; i++) {
    676          		//signal_array[i] = fir_filter(adc_data1[j++] - 512);
    677          		signal_array[i] = fir_filter(signal_array[i] - sample);	
    678          	}
    679          	
    680          	
    681          	// Searching for of importance of the amplitude of the signal on possible gap of time
    682          	for (i = 15; i < SIGNAL_ARRAY_LEN - 2; i++) {
    683          		sample = signal_array[i];
    684          		if (((sample >  signal_array[i - 1]) && (sample >  signal_array[i + 1]) && (sample > signal_array[i - 2]) && (sample > signal_array[i + 2])) ||
    685          		    ((sample >  signal_array[i - 1]) && (sample == signal_array[i + 1]) && (sample > signal_array[i - 2]) && (sample > signal_array[i + 2])) || 
    686          			((sample == signal_array[i - 1]) && (sample == signal_array[i + 1]) && (sample > signal_array[i - 2]) && (sample > signal_array[i + 2])) )   {
    687          	
    688          			if (sample > 10) {	
    689          				array_hi[i_hi] = i;
    690          				if (i_hi < EXT_ARRAY_LEN - 1) i_hi++;
    691          			}
    692          		}
    693          		
    694          		if (((sample <  signal_array[i - 1]) && (sample <  signal_array[i + 1]) && (sample < signal_array[i - 2]) && (sample < signal_array[i + 2])) ||
    695          		    ((sample <  signal_array[i - 1]) && (sample == signal_array[i + 1]) && (sample < signal_array[i - 2]) && (sample < signal_array[i + 2])) || 
    696          			((sample == signal_array[i - 1]) && (sample == signal_array[i + 1]) && (sample < signal_array[i - 2]) && (sample < signal_array[i + 2])) )   {
    697          		
    698          			if (sample < (-10)) {	
    699          				array_lo[i_lo] = i;
    700          				if (i_lo < EXT_ARRAY_LEN - 1) i_lo++;
    701          			}
    702          			
    703          		}
    704          			
    705          		if (sample < min) {
    706          			min = sample;
    707          			i_min = i;
    708          		}
    709          		if (sample > max) {
    710          			max = sample;
    711          			i_max = i;
    712          		}
    713          	}
    714          
    715          	//
    716          	delta = 0;
    717          	
    718          	// Filtering
    719          	
    720          	if ((i_lo < 2) || (i_hi < 3)) {
    721          		// Low signal
    722          		ret = 1;
    723          	}else{
    724          		T = array_hi[1] - array_hi[0];
    725          		if ((T < 9) || (T > 15))  {
    726          			// High signal
    727          			ret = 2;
    728          		}
    729          	}
    730          	
    731          	d1 = signal_array[array_hi[0]] - signal_array[array_hi[1]];
    732          	if (((d1 < -50) || (d1 > 50)) && (amp_no == 1)){
    733          		// Wery high signal
    734          		ret = 2;
    735          	}
    736          	
    737          	// Definition of delta
    738          	// Define of first low extremum after first hi extremum
    739          	for (i = 0; i < EXT_ARRAY_LEN; i++) {
    740          		if (array_lo[i] > array_hi[0]) {
    741          			i_hi = 0;
    742          			i_lo = i;
    743          			break;
    744          		}
    745          	}
    746          	//
    747          	/* ////
    748          	i_hi++;
    749          	d1 = signal_array[array_hi[i_hi++]] - signal_array[array_lo[i_lo++]];
    750          	d2 = signal_array[array_hi[i_hi]] - signal_array[array_lo[i_lo]];
    751          	delta = (d1 + d2) / 2;
    752          	*/
    753          	
    754          	//i_lo++;
    755          	d1 = signal_array[array_hi[i_hi++]] - signal_array[array_lo[i_lo]];
    756          	d2 = signal_array[array_hi[i_hi]] - signal_array[array_lo[i_lo++]];
    757          	d3 = signal_array[array_hi[i_hi++]] - signal_array[array_lo[i_lo]];
    758          	d4 = signal_array[array_hi[i_hi]] - signal_array[array_lo[i_lo]];
    759          
    760          	delta = (d1 + d2 + d3 + d4) / 4;
    761          	
    762          	if (delta > 4000) {
    763          		delta = 0;	//CONFIG->limit_norm;
    764          	}
    765          	
    766          	if ((DeviceMode == MODE_CALIBR) && ret) {
    767          		delta = 0;
    768          	}
    769          	//
    770          	return ret;
    771          }
    772          
    773          
    774          
    775          //--------------------------------------------------------------------------------
    776          // Function		: void Timer_A0_SetDelay(u16 period)
    777          // Parameters	: period in us (1..65535) - for 8 MHz DCO
    778          // Return		: None
    779          // Description	: Function initiates delay
    780          //--------------------------------------------------------------------------------
    781          void Timer_A0_SetDelay(u16 period) {
    782          	
    783          	if (period == 0) return;
    784          	
    785          	_BIC_SR(GIE);    					// Запрещаем прерывания
    786          	
    787          	fTimerA_Enable = 1;
    788          	fTimerA_Repeat = 0;
    789          	//
    790          	TA0R = 0;
    791          	TACTL 	 = TASSEL_2 + MC_1 + ID_3;  // SMCLK, up mode, div = 8
    792          	CCR0 	 = period - 1;      		// Period T(us) * F(MHz)
    793          	TACCTL0 = CCIE;						// Разрешаем прерывание таймера по достижению значения TACCCR0.
    794          	//
    795          	_BIS_SR(GIE);    					// Разрешаем прерывания
    796          }
    797          
    798          //--------------------------------------------------------------------------------
    799          // Function		: void TimerA1_DelayUs(u16 time)
    800          // Parameters	: period in us (1..32768) - for 1 MHz DCO
    801          // Return		: None
    802          // Description	: Function initiates 
    803          //--------------------------------------------------------------------------------
    804          #pragma optimize=none
    805          void TimerA1_DelayUs(u16 time) {
    806          	_BIC_SR(GIE);    					// Запрещаем прерывания
    807          	
    808          	//
    809          	TA1R = 0;
    810          	TA1CTL 	 = TASSEL_2 + MC_1;     	// SMCLK, up mode, div = 8
    811          	TA1CCR0 	 = time - 1 - 35;      	// Period T(us) * F(MHz)
    812          	//
    813          	_BIS_SR(GIE);    					// Разрешаем прерывания
    814          	
    815          	while ((TA1CCTL0 & CCIFG) == 0);
    816          	
    817          	TA1CTL 	 = 0;
    818          	TA1CCTL0 = 0;
    819          
    820          	/*
    821          	TA1R = 0;
    822          	TA1CTL 	 = TASSEL_2 + MC_1 + ID_0;  // SMCLK, up mode, div = 1
    823          	TA1CCR0  = SYS_TICK_TIME - 1;   	// Period T(us) * F(MHz)
    824          	*/
    825          }
    826          
    827          
    828          //--------------------------------------------------------------------------------
    829          // Function		: void Timer_A1_Init(void)
    830          // Parameters	: period in us (1..65535) - for 1 MHz DCO
    831          // Return		: None
    832          // Description	: Function initiates delay
    833          //--------------------------------------------------------------------------------
    834          void Timer_A1_Init(void) {
    835          	_BIC_SR(GIE);    					// Запрещаем прерывания
    836          	//
    837          	TA1R = 0;
    838          	TA1CTL 	 = TASSEL_2 + MC_1 + ID_0;  // SMCLK, up mode, div = 1
    839          	TA1CCR0  = SYS_TICK_TIME - 1;   	// Period T(us) * F(MHz)
    840          	TA1CCTL0 = CCIE;					// Разрешаем прерывание таймера по достижению значения TACCCR0.
    841          	//
    842          	_BIS_SR(GIE);    					// Разрешаем прерывания
    843          }
    844          
    845          
    846          //--------------------------------------------------------------------------------
    847          // Function		: void SoundStart(u8 snd_ind)
    848          // Parameters	: period in us (1..32768) - for 16 MHz DCO
    849          // Return		: None
    850          // Description	: Function initiates 
    851          //--------------------------------------------------------------------------------
    852          void Timer_A0_Off(void) {
    853          	_BIC_SR(GIE);    			// Запрещаем прерывания
    854          	//	
    855          	fTimerA_Enable = 0;
    856          	fTimerA_Repeat = 0;
    857          	//
    858          	TACTL = 0;  
    859          	TACCTL0 = 0;				// Запрещаем прерывание таймера по достижению значения TACCCR0.
    860          	//
    861          	_BIS_SR(GIE);    			// Разрешаем прерывания
    862          
    863          }
    864          
    865          
    866          //--------------------------------------------------------------------------------
    867          // Function		: void SetFaultMode(void)
    868          // Parameters	: None
    869          // Return		: None
    870          // Description	: 
    871          //--------------------------------------------------------------------------------
    872          void SetFaultMode(void) {
    873          	
    874          	DeviceMode = MODE_FAULT;
    875          	//
    876          	if (fault_timer == 0) { 
    877          		// No faults
    878          		fault_timer = 1000;		// 10 sec
    879          		fault_phase = 1;		// Break of BI
    880          	}
    881          	//
    882          	strob_pulse_timer = 0;		// Clear strob timer because there is breaking BI
    883          }
    884          
    885          
    886          
    887          //--------------------------------------------------------------------------------
    888          // Function		: void FaultSignalManager(void)
    889          // Parameters	: None
    890          // Return		: None
    891          // Description	: Call one time per 10 ms
    892          //--------------------------------------------------------------------------------
    893          void FaultSignalManager(void) {
    894          	
    895          	if ((DeviceMode == MODE_FIRE) || (DeviceMode == MODE_TEST) || (DeviceMode == MODE_CALIBR)) {
    896          		return;
    897          	}
    898          	//
    899          	if (DeviceFault.byte) {
    900          		DeviceMode = MODE_FAULT;
    901          		led_r = 0;
    902          		
    903          		if (DeviceFault.fStrobNone) {
    904          			// Electrical sync is fault
    905          			led_y = LED_PULSE_2;
    906          		}else
    907          		if (DeviceFault.fSignal_Low) {
    908          			// Level signal is very low
    909          			led_y = LED_PULSE_1;
    910          		}else	
    911          		if (DeviceFault.fFaultDrift) {
    912          			// Long Term Drift fault
    913          			led_y = LED_PULSE_3;
    914          		}else	
    915          		if (DeviceFault.fSignal_Hi) {
    916          			// Level signal is very big
    917          			led_y = LED_PULSE_5;
    918          		}
    919          		
    920          	}
    921          	
    922          	if (CalibrFault.byte) {
    923          		// Calibration fault signals
    924          		
    925          		DeviceMode = MODE_FAULT;
    926          		led_r = 0;
    927          		
    928          		if (CalibrFault.fCalibr_Low) {
    929          			led_y = LED_PULSE_4;
    930          		}else
    931          		if (CalibrFault.fCalibr_Hi) {
    932          			led_y = LED_PULSE_5;
    933          		}
    934          		//
    935          		BREAK_ENABLE();				// Disable of BI
    936          		FIRE_CLR();					// Disable Fire current consumption
    937          		//
    938          		fault_timer = 0;
    939          		fault_phase = 0;
    940          	}
    941          		
    942          	if ((DeviceFault.byte == 0) && (CalibrFault.byte == 0)) {
    943          		if (DeviceMode == MODE_FAULT) {
    944          			DeviceMode = MODE_NORM;
    945          			
    946          			led_r = 0;
    947          			led_y = 0;
    948          			
    949          			fault_timer = 0;
    950          			fault_phase = 0;
    951          			
    952          			strob_pulse_timer = 0;
    953          			
    954          			BREAK_DISABLE();		// Enable of BI
    955          			FIRE_CLR();				// Disable Fire current consumption
    956          		}
    957          	}
    958          	//
    959          	if (fault_timer) {
    960          		fault_timer--;
    961          		//
    962          		if (fault_timer == 0) {
    963          			if (fault_phase) {
    964          				fault_phase = 0;
    965          				fault_timer = 2000;		// 20 sec
    966          			}else{
    967          				fault_phase = 1;
    968          				fault_timer = 1000;		// 10 sec
    969          			}
    970          		}
    971          		//
    972          		if (fault_phase == 1) {
    973          			BREAK_ENABLE();			// Disable of BI
    974          		}else{
    975          			BREAK_DISABLE();		// Enable of BI
    976          		}
    977          
    978          	}
    979          }
    980          
    981          
    982          //--------------------------------------------------------------------------------
    983          // Function		: void LedTestValueManager(void)
    984          // Parameters	: None
    985          // Return		: None
    986          // Description	: 
    987          //--------------------------------------------------------------------------------
    988          //#pragma optimize=none
    989          void LedTestValueManager(void) {
    990          	if (delta < 150) {
    991          		led_r = LED_PULSE_1;
    992          		led_y = LED_FULL;
    993          	}else
    994          	if (delta < 250) {
    995          		led_r = LED_PULSE_2;
    996          		led_y = LED_FULL;
    997          	}else
    998          	if (delta < 450) {
    999          		led_r = LED_PULSE_3;
   1000          		led_y = LED_FULL;
   1001          	}else
   1002          	if (delta < 550) {
   1003          		led_r = LED_PULSE_4;
   1004          		led_y = LED_FULL;
   1005          	}else{
   1006          		led_r = LED_PULSE_5;
   1007          		led_y = LED_FULL;
   1008          	}
   1009          }
   1010          
   1011          
   1012          //---------------------------------------------------------------------------------
   1013          // Function		: void AMP_SetGain(u8 value)
   1014          // Parameters	: None
   1015          // Return		: None
   1016          // Description	: Initialization interrupts from RX Sniff CC112x (GPIO2)
   1017          //---------------------------------------------------------------------------------
   1018          void ADC_SetParam(void) {
   1019          	
   1020          	gain = CONFIG->Gain & 0x0F;
   1021          	reference = CONFIG->Gain >> 4;
   1022          	amp_no = CONFIG->AMP_No;
   1023          	
   1024          }
   1025          
   1026          //---------------------------------------------------------------------------------
   1027          // Function		: void AMP_SetGain(u8 value)
   1028          // Parameters	: None
   1029          // Return		: None
   1030          // Description	: Initialization interrupts from RX Sniff CC112x (GPIO2)
   1031          //---------------------------------------------------------------------------------
   1032          #pragma optimize=none
   1033          void CalibrationResultAnalise(void) {
   1034          	int i;
   1035          	u16 prev, temp, min = 0xFFFF, max = 0;
   1036          	u8  i_ok = 0xFF, i_ok2 = 0xFF;
   1037          	u8  fault = 0;
   1038          	u16 d;
   1039          	u8  corr = 0;
   1040          	
   1041          	prev = s_array[0];
   1042          	for (i = 0; i < CALIBR_STAGES; i++) {
   1043          		temp = s_array[i];
   1044          		//
   1045          		if (temp > max) {
   1046          			max = temp;
   1047          		}
   1048          		if (temp < min) {
   1049          			min = temp;
   1050          		}
   1051          			
   1052          		if (((temp >= 90) && (temp <= 200)) || 
   1053          			((temp >= 480) && (temp <= 600))) {
   1054          			i_ok = i;
   1055          		}
   1056          		if ((temp >= 200) && (temp <= 480)) {
   1057          			i_ok2 = i;
   1058          		}
   1059          		//
   1060          		if ((prev > 100) && (temp == 0) && (i <= 4)) {
   1061          			fault = 1;	// Signal is vefy Hi
   1062          		}
   1063          		prev = temp;
   1064          	}
   1065          	//
   1066          	if (q_array[0] == 2) {
   1067          		// Signal is vefy Hi
   1068          		fault = 1;
   1069          	}
   1070          	//
   1071          		
   1072          	if (fault) {
   1073          		// End of calibration - very Hi signal - ERROR
   1074          		//DeviceFault.fSignal_Hi = 1;
   1075          		//DeviceMode = MODE_FAULT;
   1076          		CalibrFault.fCalibr_Hi = 1;
   1077          	}else
   1078          	if ((i_ok2 < CALIBR_STAGES) || (i_ok < CALIBR_STAGES)) {
   1079          		if (i_ok2 < CALIBR_STAGES) {
   1080          			i = i_ok2; 
   1081          		}else{
   1082          			i = i_ok;
   1083          		}
   1084          		//
   1085          		// Calibration Ok!!!
   1086          		//
   1087          		d = s_array[i];
   1088          		//q = q_array[i]; 
   1089          		//
   1090          		if (i == 0) {
   1091          			if (d >= 480) {
   1092          				CalibrFault.fCalibr_Hi = 1;
   1093          				StoragePropertyByte(eeCALIBR_FAULT_OFFSET, CalibrFault.byte);
   1094          				return;
   1095          			}
   1096          			//
   1097          			if (d >= 330) {
   1098          				corr = 2;
   1099          			}else
   1100          			if (d >= 170) {
   1101          				corr = 1;
   1102          			}
   1103          		}
   1104          			
   1105          		// That's Ok
   1106          		//SetLevels(d);
   1107          		SetLevelsFromCalibr(d, corr);
   1108          		SetLimitCompens();
   1109          		
   1110          		amp_no = calibr_sequence[i][0];
   1111          		gain = calibr_sequence[i][1];
   1112          		reference = calibr_sequence[i][2];
   1113          		
   1114          		StoragePropertyByte(ee_GAIN, gain + (reference << 4));
   1115          		StoragePropertyByte(ee_AMP_NO, amp_no);
   1116          		StoragePropertyWord(eeCONFIG_REG_OFFSET, cfg_reg.word);
   1117          		//
   1118          		DeviceMode = MODE_NORM;
   1119          		//...
   1120          		FIRE_CLR();				// Disable Fire current consumption
   1121          		//
   1122          		AMP_SetGain(gain);
   1123          		//
   1124          	}else
   1125          	if (max < SYGNAL_MIN_VALUE) {
   1126          		// Signal is Low
   1127          		CalibrFault.fCalibr_Low = 1;
   1128          	}else
   1129          	if (min > SYGNAL_MAX_VALUE) {
   1130          		// Signal is Hi
   1131          		CalibrFault.fCalibr_Hi = 1;
   1132          	}
   1133          	//
   1134          	FIRE_CLR();				// Disable Fire current consumption
   1135          	StoragePropertyByte(eeCALIBR_FAULT_OFFSET, CalibrFault.byte);
   1136          }
   1137          	
   1138          
   1139          //========================================================
   1140          //                 ---  M A I N  ----
   1141          //========================================================
   1142          //--------------------------------------------------------------------------------
   1143          // Function		: void main(void)
   1144          // Parameters	: None
   1145          // Return		: None
   1146          // Description	: Main function. Contains main loop.
   1147          //--------------------------------------------------------------------------------
   1148          void main(void) {
   1149          	u8	byte, sh, len;
   1150          	int i;
   1151          	u8  loc_buf[2];
   1152          	u8  n_counter = 0;
   1153          	u8  quality;
   1154          	u16	summa = 0;
   1155          	u8	fire_level_counter = 0;
   1156          	u8	QualityFaultCounter = 0;
   1157          	u8	led_clk;
   1158          	u16	led_timer = 0;
   1159          	u8	timerA1_blank = 0;
   1160          	
   1161          	// Initialization variables and GPIO
   1162          	WDTCTL = WDTPW + WDTHOLD;				// отключаем сторожевой таймер
   1163          	// GIPIO Init
   1164          	GPIO_Init();
   1165          		
   1166          	// Init internal RC osc.
   1167          	BCSCTL1 = CALBC1_1MHZ; 					// Используем частоту 1 MГц
   1168          	DCOCTL =  CALDCO_1MHZ;
   1169          	
   1170          	DelayMs(100);
   1171          	
   1172          	// Initialization code for VLO
   1173          	__set_R4_register(0);
   1174          	//
   1175          	BCSCTL3 |= LFXT1S_2;                    // Select VLO as low freq clock
   1176          	// End initialization code
   1177          	
   1178          	WDTCTL = WDT_ADLY_1000;                   // Interval timer	/* for 50 ms */
   1179          	//WDTCTL = WDT_ADLY_1_9;                   // Interval timer	/* for 5.9 ms */
   1180          	IE1 |= WDTIE;                           // Enable WDT interrupt
   1181          	//
   1182          	if (IFG1 & WDTIFG) {
   1183          		// Reset WDT
   1184          		#if (SYS_FAULT_ENABLE == 1)
   1185          		DeviceFault.fFaultSWReset = 1;
   1186          		#endif
   1187          	}
   1188          	IFG1 = 0;
   1189          	//	
   1190          	DeviceMode = MODE_NORM;
   1191          	
   1192          	sleep();
   1193          	
   1194          //	DelayMs(2000);
   1195          	
   1196          	Led_Flash(10);
   1197          	DelayMs(300);
   1198          	Led_Flash(10);
   1199          	
   1200          	BREAK_DISABLE();					// Enable BI
   1201          //	DelayMs(7000);
   1202          	sleep();
   1203          	
   1204          	_BIS_SR(GIE);    					// Interrupt enable
   1205          	DeviceStart();
   1206          
   1207          	AMP_SetGain(CONFIG->Gain);
   1208          	ADC_SetParam();
   1209          	cfg_reg = CONFIG->config_reg;
   1210          	
   1211          	STROB_IE_Enable();
   1212          	Timer_A1_Init();
   1213          	
   1214          	DelayMs(2000);
   1215          	
   1216          	start_timer = 400;		// 4 sec
   1217          	WDTCTL = WDT_ADLY_16;                   // Interval timer	/* for 50 ms */
   1218          // *****************************************************************
   1219          // ******************   M A I N   L O O P  *************************
   1220          // *****************************************************************
   1221          	while(1) {
   1222          		
   1223          		//-------------------------------------------------------------------------------
   1224          		//
   1225          		// ******** Обработчики событий ********
   1226          		//
   1227          		//-------------------------------------------------------------------------------
   1228          		
   1229          //-------------------------------------------------------------------------------
   1230          // TimerA0 Event		
   1231          //-------------------------------------------------------------------------------
   1232          		if (fTimerA_On) {				// Закончен период ожидания измерительных импульсов
   1233          			fTimerA_On = 0;
   1234          			
   1235          			BCSCTL1 = CALBC1_16MHZ; 	// Используем частоту 16 MГц
   1236          			DCOCTL =  CALDCO_16MHZ;
   1237          			//
   1238          			TA1CCR0  = 0xFFFF - 1;   	// ~ Compensation of frequence increase
   1239          			//
   1240          			Timer_A0_Off();				
   1241          			
   1242          			ADC_MeasureStart();
   1243          		
   1244          			timerA1_blank = 4;
   1245          		}
   1246          
   1247          //-------------------------------------------------------------------------------
   1248          // fTimer50msOn Event				
   1249          //-------------------------------------------------------------------------------
   1250          		if (fTimer50msOn) {		// Получен следующий 50мс интервал
   1251          			fTimer50msOn = 0;
   1252          			//
   1253          			Timer50msCounter = 0;
   1254          		}
   1255          		
   1256          //-------------------------------------------------------------------------------
   1257          // TimerA1 Event (SysTick) 10 ms
   1258          //-------------------------------------------------------------------------------
   1259          		if (fTimerA1_On) {				// Получен следующий интервал timer
   1260          			fTimerA1_On = 0;
   1261          			
   1262          			if (start_timer) {
   1263          				start_timer--;
   1264          				if (start_timer == 0) {
   1265          					CalibrFault.byte = CONFIG->calibr_fault;
   1266          
   1267          					flash_period_timer = 500;	// Need flash after 5 sec
   1268          					strob_pulse_timer = 0;
   1269          				}
   1270          			}
   1271          			
   1272          			//TEST2_OUT ^= TEST2_BIT;
   1273          			//
   1274          			if (timerKeyDown) {
   1275          				timerKeyDown++;
   1276          				if (timerKeyDown > 200 ) {			// > 2 sec - Start Calibration
   1277          					// CALIBRATION Start
   1278          					//
   1279          					JP1_Define();			// Define JP1 on BVS state
   1280          					if (jp1_state == 0) {
   1281          						// JP1 is Open 
   1282          						cfg_reg.fDrift = 1;
   1283          					}else{
   1284          						cfg_reg.fDrift = 0;
   1285          					}
   1286          					//
   1287          					// Calibration mode init 
   1288          					DeviceMode = MODE_CALIBR;
   1289          					
   1290          					// Calibration from most amp to small
   1291          					FIRE_SET();				// Set Fire output key
   1292          					FAULT_CLR();			// Clear Fault Signal
   1293          					BREAK_DISABLE();		// Enable of transmitter
   1294          					
   1295          					DeviceFault.fStrobNone = 0;
   1296          					strob_pulse_timer = 0;
   1297          					//
   1298          					calibr_stage = 0;
   1299          					n_counter = 0;
   1300          					summa = 0;
   1301          					//
   1302          					amp_no = calibr_sequence[calibr_stage][0];
   1303          					gain = calibr_sequence[calibr_stage][1];
   1304          					reference = calibr_sequence[calibr_stage][2];
   1305          					//
   1306          					AMP_SetGain(gain);
   1307          					
   1308          					QualityFaultCounter = 0;
   1309          					DeviceFault.byte = 0;
   1310          					CalibrFault.byte = 0;
   1311          					fault_timer = 0;
   1312          					fault_phase = 0;
   1313          					
   1314          					RED_CLR();
   1315          					YEL_CLR();
   1316          					
   1317          					timerKeyDown = 0;
   1318          					
   1319          					flash_period_timer = 120;	// Flash after 1.2 sec
   1320          					light_timer = 7;			// Value - the power of LED light
   1321          				}
   1322          			}
   1323          			
   1324          			if (zero_timer) {
   1325          				zero_timer++;
   1326          			}
   1327          				
   1328          			if (fault_chain_timer)  {
   1329          				fault_chain_timer--;
   1330          				if (DeviceMode != MODE_FIRE) {
   1331          					if (fault_chain_timer == 0) {
   1332          						if (fault_sequence[fault_chain_ind] == 0) {
   1333          							fault_chain_ind = 0;
   1334          							DeviceMode = MODE_NORM;
   1335          						}else{
   1336          							DeviceMode = fault_sequence[fault_chain_ind++];
   1337          							fault_chain_timer = getTimerValue(fault_sequence[fault_chain_ind++]);
   1338          							//
   1339          							switch (DeviceMode) {
   1340          								case MODE_FIRE:
   1341          									FIRE_SET();
   1342          									//
   1343          									RED_SET();
   1344          									YEL_CLR();
   1345          									fault_chain_timer = 0;
   1346          									strob_pulse_timer = 0;
   1347          									zero_timer = 0;
   1348          									BREAK_DISABLE();		// Enable of transmitter
   1349          									DeviceFault.fSignal_Low = 0;
   1350          									break;
   1351          								case MODE_FAULT:
   1352          									BREAK_ENABLE();			// Disable of transmitter
   1353          									break;
   1354          								case MODE_NORM:
   1355          									strob_pulse_timer = 0;
   1356          									zero_timer = 0;
   1357          									DeviceFault.fSignal_Low = 0;
   1358          									BREAK_DISABLE();		// Enable of transmitter
   1359          							}
   1360          						}
   1361          					}
   1362          				}
   1363          			}
   1364          			
   1365          			if (timerMain) {
   1366          				timerMain--;
   1367          				if (timerMain == 0) {
   1368          					if (DeviceMode == MODE_TEST) {
   1369          						DeviceMode = MODE_NORM;
   1370          						RED_CLR();
   1371          						YEL_CLR();
   1372          						FIRE_CLR();
   1373          					}
   1374          				}
   1375          			}
   1376          			//
   1377          			// Setting signals in Fault Mode (LEDs and other pins)
   1378          			FaultSignalManager();
   1379          			//
   1380          			
   1381          			if (timerA1_blank) {
   1382          				timerA1_blank--;
   1383          			}else{
   1384          				// ---- LED Indication ----
   1385          				//
   1386          				if (light_timer) {
   1387          					light_timer--;
   1388          					//
   1389          					if ((DeviceMode == MODE_NORM) || (DeviceMode == MODE_PREFIRE) || (DeviceMode == MODE_PREPREFIRE)) {
   1390          						RED_SET();
   1391          						YEL_CLR();
   1392          					}else
   1393          					//
   1394          					if (DeviceMode == MODE_CALIBR) {
   1395          						RED_SET();
   1396          						YEL_SET();
   1397          					}
   1398          				}else{
   1399          					//
   1400          					if ((DeviceMode == MODE_NORM) || (DeviceMode == MODE_CALIBR) || (DeviceMode == MODE_PREFIRE) || (DeviceMode == MODE_PREPREFIRE)) {
   1401          						RED_CLR();
   1402          						YEL_CLR();
   1403          					}
   1404          				}
   1405          				//	
   1406          				if ((DeviceMode == MODE_FAULT) || (DeviceMode == MODE_TEST)) {
   1407          					//
   1408          					// LED management
   1409          					//
   1410          					if (light_sync >= 3) {
   1411          						light_sync = 0;
   1412          						led_sh = 0x80000000;
   1413          						//
   1414          						led_timer = 300;		// 3 sec period
   1415          					}
   1416          					
   1417          					if (led_timer) {
   1418          						led_timer--;
   1419          					}else{
   1420          						led_timer = 300;		// 3 sec period
   1421          						led_sh = 0x80000000;
   1422          						//
   1423          						light_sync = 0;
   1424          					}
   1425          					//
   1426          					if (++led_clk >= 4) {		// T = 30 ms
   1427          						led_clk = 0;
   1428          						//
   1429          						if (led_r & led_sh) {
   1430          							RED_SET();
   1431          							TEST2_SET();
   1432          						}else{
   1433          							RED_CLR();
   1434          							TEST2_CLR();
   1435          						}
   1436          						//
   1437          						if (led_y & led_sh) {
   1438          							YEL_SET(); 
   1439          						}else{
   1440          							YEL_CLR();
   1441          						}
   1442          						//
   1443          						if (DeviceMode == MODE_TEST) {
   1444          							YEL_SET(); 
   1445          						}
   1446          						//
   1447          						led_sh >>= 1;
   1448          					}
   1449          				}
   1450          			} // End indication
   1451          			//
   1452          			//
   1453          			// Strob pulse diagnostic 
   1454          			if ((strob_pulse_timer == 200) || (strob_pulse_timer == 1800)){
   1455          				STROB_IE_Enable();
   1456          			}
   1457          			if (++strob_pulse_timer >= 2000) {	// 20 sec
   1458          				strob_pulse_timer = 0;
   1459          				if (DeviceFault.fStrobNone == 0) {
   1460          					if (CalibrFault.byte == 0) {
   1461          						DeviceFault.fStrobNone = 1;
   1462          						SetFaultMode();
   1463          					}
   1464          				}
   1465          			}
   1466          			//
   1467          			if (flash_period_timer) {
   1468          				flash_period_timer--;
   1469          				if (flash_period_timer == 0) {
   1470          					flash_period_timer = 120;	// Flash after 1.2 sec
   1471          					if ((DeviceMode == MODE_NORM) || (DeviceMode == MODE_PREPREFIRE)){
   1472          						light_timer = 1;				// Value - the light power
   1473          					}else
   1474          					if (DeviceMode == MODE_CALIBR) {
   1475          						light_timer = 7;				// Value - the light power
   1476          					}
   1477          				}
   1478          			}
   1479          			sleep();	
   1480          		} // if (fTimerA1_On 10 ms)
   1481          		
   1482          //-------------------------------------------------------------------------------
   1483          // End of samples of ADC Event
   1484          		if (fEndOfSamples) {	// End of samples of ADC Event
   1485          			fEndOfSamples = 0;
   1486          
   1487          			AMP_PWR_OFF();						// AMP Power Supply Disable			
   1488          			
   1489          			//VREF_Off();						// Vref Disable
   1490          			ADC10CTL0 &= ~ENC;
   1491          			while (ADC10CTL1 & BUSY);           // Wait if ADC10 core is active 
   1492          			ADC10CTL0 &= ~REFON;
   1493          			
   1494          
   1495          			//AMP_Off_Timer = CONFIG->timer_calibr - CONFIG->timer_calibr / 4 + 1;	//CONFIG->timer_calibr - CONFIG->timer_calibr / 4 + 1;
   1496          			//
   1497          			BCSCTL1 = CALBC1_8MHZ; 					// Используем частоту 1 MГц
   1498          			DCOCTL =  CALDCO_8MHZ;
   1499          			//
   1500          			TA1CCR0  = 0xFFFF - 1;   			// ~ Compensation of frequence increase
   1501          			//
   1502          			DelayUs(1);
   1503          			//
   1504          			if (fSendingGraph) {
   1505          				loc_buf[0] = Q_SEND_GRAPH1;
   1506          				loc_buf[1] = SIGNAL_ARRAY_LEN * 2;
   1507          				SoftUART_TxString(loc_buf, 2);
   1508          				//
   1509          				SoftUART_TxString((u8*)&signal_array[0], SIGNAL_ARRAY_LEN * 2);
   1510          			}
   1511          			//
   1512          			//
   1513          			if (start_timer || CalibrFault.byte || DeviceFault.fFaultDrift) {
   1514          				goto label_light;
   1515          			}
   1516          			
   1517          			STROB_IE_Enable();
   1518          			strob_pulse_timer = 0;
   1519          		
   1520          			//TEST2_SET();
   1521          			quality = SignalAnalysis();
   1522          			//TEST2_CLR();
   1523          			//
   1524          			BCSCTL1 = CALBC1_1MHZ; 					// Используем частоту 1 MГц
   1525          			DCOCTL =  CALDCO_1MHZ;
   1526          			TA1CCR0  = 1 * SYS_TICK_TIME - 1;   	// Period T(us) * F(MHz)
   1527          			DelayUs(1);
   1528          			//
   1529          			//	
   1530          			if (DeviceMode == MODE_CALIBR) {
   1531          				//
   1532          				// -------- CALIBRATION ---------
   1533          				//
   1534          				n_counter++;
   1535          				summa += delta;
   1536          				
   1537          				if (n_counter >= 2) {
   1538          					delta = summa / n_counter;
   1539          					n_counter = 0;
   1540          					summa = 0;
   1541          					//
   1542          					s_array[calibr_stage] = delta;
   1543          					q_array[calibr_stage] = quality;
   1544          					//
   1545          					if (++calibr_stage >= CALIBR_STAGES) {
   1546          						// End of calibration
   1547          						//
   1548          						CalibrationResultAnalise();
   1549          						if (CalibrFault.byte) {
   1550          							DeviceMode = MODE_FAULT;
   1551          						}
   1552          						//
   1553          						goto label_light;
   1554          					}
   1555          					//
   1556          					//	Set new	 Amp_No	Gain  Reference
   1557          					amp_no = calibr_sequence[calibr_stage][0];
   1558          					gain = calibr_sequence[calibr_stage][1];
   1559          					reference = calibr_sequence[calibr_stage][2];
   1560          					//
   1561          					AMP_SetGain(gain);
   1562          					//
   1563          				}
   1564          			}else
   1565          			//
   1566          			// -------- NORM behavior -------------
   1567          			//
   1568          			if (quality == 2) {	
   1569          				// Very high signal
   1570          				if (++QualityFaultCounter > 10) {
   1571          					CalibrFault.fCalibr_Hi = 1;
   1572          					QualityFaultCounter = 0;
   1573          				}
   1574          				//
   1575          				goto label_light;
   1576          			}else{
   1577          				QualityFaultCounter = 0;
   1578          			}
   1579          			
   1580          			if (((DeviceMode == MODE_NORM) || (DeviceMode == MODE_PREPREFIRE)) && fault_chain_timer) {
   1581          				// Обрабатывается полное перекрытие
   1582          				if (delta > getZeroLevel()) {
   1583          					fault_chain_timer = 0;
   1584          					fault_chain_ind = 0;
   1585          					DeviceFault.fSignal_Low = 0;
   1586          				}
   1587          			}
   1588          			
   1589          			if (((DeviceMode == MODE_NORM) || (DeviceMode == MODE_PREPREFIRE)) && (fault_chain_timer == 0)) {
   1590          				if ((delta >= CONFIG->limit_fire) && (delta <= SYGNAL_MAX_VALUE)) {
   1591          					// Reset all counters
   1592          					fire_level_counter = 0;
   1593          					hi_signal_counter = 0;
   1594          					zero_timer = 0;
   1595          				}
   1596          								
   1597          				if (delta <= getZeroLevel()) {
   1598          					if (zero_timer == 0) {	
   1599          						zero_timer = 1;
   1600          					}else
   1601          					if (zero_timer > 1000) {	// 10 sec
   1602          						// Полное перекрытие 
   1603          						fault_chain_ind = 0;
   1604          						DeviceMode = fault_sequence[fault_chain_ind++];
   1605          						fault_chain_timer = getTimerValue(fault_sequence[fault_chain_ind++]);
   1606          						DeviceFault.fSignal_Low = 1;
   1607          						zero_timer = 0;
   1608          						//
   1609          						BREAK_ENABLE();			// Disable of transmitter
   1610          						//
   1611          					}
   1612          				}else{
   1613          					zero_timer = 0;
   1614          					//
   1615          					if (delta < CONFIG->limit_prefire) {
   1616          						DeviceMode = MODE_PREPREFIRE;
   1617          					}
   1618          					
   1619          					if (DeviceMode == MODE_PREPREFIRE) {
   1620          						if (delta > CONFIG->limit_prefire) {
   1621          							DeviceMode = MODE_NORM;
   1622          						}
   1623          					}
   1624          					
   1625          					if (delta < CONFIG->limit_fire) {
   1626          						fire_level_counter = 5;
   1627          						DeviceMode = MODE_PREFIRE;
   1628          					}
   1629          					
   1630          					// Hi signal management
   1631          					if (delta > SYGNAL_MAX_VALUE) {
   1632          						// Very high signal
   1633          						hi_signal_counter++;
   1634          						if (hi_signal_counter >= 10) {
   1635          							//DeviceMode = MODE_FAULT;
   1636          							CalibrFault.fCalibr_Hi = 1;
   1637          							hi_signal_counter = 0;
   1638          						}
   1639          					}
   1640          				}
   1641          			}else
   1642          			if (DeviceMode == MODE_PREFIRE) {
   1643          				//
   1644          				// Защита от плавного изменения уровня сигнала
   1645          				if ((delta == 0) && (delta_last > 0)) {
   1646          					fire_level_counter = 10;
   1647          				}
   1648          				//	
   1649          				if ((delta <= getZeroLevel()) && (fire_level_counter == 5)) {
   1650          					if (zero_timer == 0) {	
   1651          						zero_timer = 1;
   1652          						DeviceMode = MODE_NORM;
   1653          					}
   1654          				}else
   1655          				if (delta < CONFIG->limit_fire) {
   1656          					if (--fire_level_counter == 0) {
   1657          						DeviceMode = MODE_FIRE;
   1658          						FIRE_SET();
   1659          						RED_SET();
   1660          						YEL_CLR();
   1661          						DeviceFault.byte = 0;
   1662          					}
   1663          				}else{
   1664          					DeviceMode = MODE_NORM;
   1665          				}
   1666          				//
   1667          				delta_last = delta;
   1668          			}
   1669          			//
   1670          			if (CONFIG->config_reg.fDrift) {
   1671          				// if JP1 state is open
   1672          				if ((DeviceMode == MODE_NORM) && delta) {
   1673          					// Long Term Drift Adjustment
   1674          					DriftSumma += delta;
   1675          					DriftCounter++;
   1676          					if (DriftCounter >= DRIFT_SAMPLES_MAX) {
   1677          						DriftLevel = DriftSumma / DriftCounter;
   1678          						//
   1679          						if ((u16)DriftLevel < CONFIG->limit_drift) {
   1680          							//
   1681          							DeviceFault.fFaultDrift = 1;
   1682          							SetFaultMode();
   1683          							//
   1684          							SetLevels(CONFIG->limit_drift);
   1685          						}else{
   1686          							SetLevels((u16)DriftLevel);
   1687          						}
   1688          						//	
   1689          						ClearDriftVar();
   1690          						//
   1691          					}
   1692          				}
   1693          			}
   1694          			//			
   1695          			//
   1696          label_light:			
   1697          			//
   1698          			BCSCTL1 = CALBC1_1MHZ; 					// Используем частоту 1 MГц
   1699          			DCOCTL =  CALDCO_1MHZ;
   1700          			TA1CCR0  = 1 * SYS_TICK_TIME - 1;   	// Period T(us) * F(MHz)
   1701          			//
   1702          			DelayUs(1);
   1703          			//
   1704          			if (fSendingGraph) {
   1705          				//
   1706          				BCSCTL1 = CALBC1_8MHZ; 					// Используем частоту 8 MГц
   1707          				DCOCTL =  CALDCO_8MHZ;
   1708          				TA1CCR0  = 0xFFFF - 1;   				// ~ Compensation of frequence increase
   1709          				//
   1710          				//
   1711          				for (i = 0; i < SIGNAL_ARRAY_LEN; i++) {
   1712          					signal_array[i] += 350;
   1713          				}
   1714          				
   1715          				loc_buf[0] = Q_SEND_GRAPH2;
   1716          				loc_buf[1] = SIGNAL_ARRAY_LEN * 2;
   1717          				SoftUART_TxString(loc_buf, 2);
   1718          				//
   1719          				SoftUART_TxString((u8*)&signal_array[0], SIGNAL_ARRAY_LEN * 2);
   1720          				
   1721          				SoftUART_TxString((u8*)&delta, 2);
   1722          				
   1723          				fSendingGraph = 0;
   1724          				//
   1725          				BCSCTL1 = CALBC1_1MHZ; 					// Используем частоту 1 MГц
   1726          				DCOCTL =  CALDCO_1MHZ;
   1727          				TA1CCR0  = 1 * SYS_TICK_TIME - 1;   	// Period T(us) * F(MHz)
   1728          				//
   1729          			}
   1730          			//
   1731          			//
   1732          			// Indication
   1733          			//
   1734          			if (DeviceMode == MODE_NORM) {
   1735          				light_timer = 1;				// Value - the light power
   1736          				flash_period_timer = 120;		// Flash after 1.2 sec
   1737          			}
   1738          			//
   1739          			if ((DeviceMode == MODE_PREFIRE) || (DeviceMode == MODE_PREPREFIRE)) {
   1740          				light_timer = 4;				// Value - the light power
   1741          				flash_period_timer = 120;		// Flash after 1.2 sec
   1742          			}
   1743          			//
   1744          			if (DeviceMode == MODE_CALIBR) {
   1745          				light_timer = 7;				// Value - the light power
   1746          				flash_period_timer = 120;		// Flash after 1.2 sec
   1747          			}
   1748          			//
   1749          			if (DeviceMode == MODE_TEST) {
   1750          				// Indication sygnal level
   1751          				LedTestValueManager();			
   1752          				//
   1753          			}
   1754          			//
   1755          			light_sync++;
   1756          			led_timer = 400;	//4 sec
   1757          			
   1758          			STROB_IE_Enable();
   1759          		}
   1760          		
   1761          //-------------------------------------------------------------------------------
   1762          // Strobe StartPulse Event		
   1763          		if (fStartPulse) {			// Start pulse was received
   1764          			fStartPulse = 0;
   1765          			//
   1766          			AMP_PWR_ON();						// AMP Power Supply Enable
   1767          			// Vref Enable
   1768          			if (DeviceMode == MODE_CALIBR) {
   1769          				ADC_MeasureInit(amp_no, reference);
   1770          			}else{
   1771          				ADC_MeasureInit(CONFIG->AMP_No, reference);
   1772          			}
   1773          			
   1774          			//TEST2_SET();
   1775          			
   1776          			_BIC_SR(GIE);    			// Запрещаем прерывания
   1777          //			Timer_A0_SetDelay(2250);
   1778          			Timer_A0_SetDelay(1500);
   1779          			_BIS_SR(GIE);    			// Разрешаем прерывания
   1780          			//
   1781          			BCSCTL1 = CALBC1_8MHZ; 		// Используем частоту 8 MГц
   1782          			DCOCTL =  CALDCO_8MHZ;
   1783          			//
   1784          			TA1CCR0  = 0xFFFF - 1;   	// ~ Compensation of frequence increase
   1785          			//
   1786          			// For define the presence of strob pulses
   1787          			strob_pulse_timer = 0;
   1788          			DeviceFault.fStrobNone = 0;
   1789          			//
   1790          			fault_phase = 0;
   1791          			fault_timer = 0;
   1792          		}
   1793          		
   1794          
   1795          //-------------------------------------------------------------------------------
   1796          // KEY DOWN event		
   1797          		if (fButtonDownOn) {									// Нажата кнопка
   1798          			fButtonDownOn = 0;
   1799          			//...
   1800          			timerKeyDown = 1;
   1801          			//
   1802          		} // if (fButtonDownOn)
   1803          		
   1804          //-------------------------------------------------------------------------------
   1805          // KEY UP event
   1806          		if (fButtonUpOn) {			// Отжата кнопка
   1807          			fButtonUpOn = 0;
   1808          
   1809          			if ((timerKeyDown > 4) && (timerKeyDown < 150))  {	// < 1.5 sec
   1810          				// The short pressure on the button
   1811          				if ((DeviceMode == MODE_NORM) || (DeviceMode == MODE_PREFIRE) || (DeviceMode == MODE_PREPREFIRE)) {
   1812          					DeviceMode = MODE_TEST;
   1813          					DeviceFault.byte = 0;	// Reset all faults
   1814          					FIRE_SET();				// Set fire mode current consumption
   1815          					RED_CLR();
   1816          					YEL_SET();
   1817          					timerMain = 12000;		// 120 sec
   1818          					led_sh = 0;
   1819          					led_timer = 0;			// Устраняем задержку оптической индикации
   1820          					led_clk = 0xFF;
   1821          				}else
   1822          				//	
   1823          				if (DeviceMode == MODE_TEST) {
   1824          					DeviceMode = MODE_NORM;
   1825          					DeviceFault.byte = 0;	// Reset all faults
   1826          					//led_timer = 0;
   1827          					RED_CLR();
   1828          					YEL_CLR();
   1829          					FIRE_CLR();
   1830          				}else
   1831          				//
   1832          				if (DeviceMode == MODE_FIRE) {
   1833          					DeviceMode = MODE_NORM;
   1834          					DeviceFault.byte = 0;	// Reset all faults
   1835          					RED_CLR();
   1836          					YEL_CLR();
   1837          					FIRE_CLR();				// Disable Fire Mode consumption
   1838          					led_r = 0;
   1839          					led_y = 0;
   1840          				}
   1841          			}
   1842          			//
   1843          			timerKeyDown = 0;
   1844          		} // if (fButtonUpOn) {
   1845          
   1846          		
   1847          //-------------------------------------------------------------------------------
   1848          // Soft UART Rx Hundler
   1849          		if (fRxLineDownOn) {
   1850          			uart_rx_ind = 0;
   1851          			//
   1852          label_rx_continue:
   1853          			fRxLineDownOn = 0;
   1854          			//
   1855          			DelayUs_8MHz(25);		// Delay to center of pulse
   1856          			//
   1857          			//TEST2_SET();
   1858          			//TEST2_CLR();
   1859          			//
   1860          			if ((INTER_BIT & INTER_IN) == 0) {
   1861          				SoftUART_SetReceiveByte();
   1862          				
   1863          			}else{
   1864          				//
   1865          				BCSCTL1 = CALBC1_1MHZ; 					// Используем частоту 1 MГц
   1866          				DCOCTL =  CALDCO_1MHZ;
   1867          				//
   1868          				TA1CCR0  = 1 * SYS_TICK_TIME - 1;   	// Period T(us) * F(MHz)
   1869          				//
   1870          				continue;		// False pulse
   1871          			}
   1872          			sh = 0x01;
   1873          			byte = 0;
   1874          			while (sh) {
   1875          				if (fTimerA_On) {
   1876          					fTimerA_On = 0;
   1877          					//
   1878          					//TEST2_SET();
   1879          					//TEST2_CLR();
   1880          					//
   1881          					if (INTER_BIT & INTER_IN) {
   1882          						byte |= sh;
   1883          					}
   1884          					sh <<= 1;
   1885          				}
   1886          			}
   1887          			// Receive byte
   1888          			SoftUART_ResetReceiveByte();
   1889          			//
   1890          			if (uart_rx_ind == 0) {
   1891          				// Begin of packet
   1892          				len = packet_len_table[byte];
   1893          				if (len > UART_BUF_LEN) {
   1894          					len = UART_BUF_LEN;
   1895          				}
   1896          			}
   1897          				
   1898          			*(uart_rx_buf+uart_rx_ind++) = byte;
   1899          			if (uart_rx_ind >= len) {
   1900          				// Parse of packet
   1901          				//...
   1902          				SoftUART_RxParse();
   1903          				INTER_IFG &= ~INTER_BIT;    				// Обнуляем флаг прерывания
   1904          				fRxLineDownOn = 0;
   1905          			}else{
   1906          				//			
   1907          				uart_timer = 4;								// 200 ms timeout to next byte
   1908          				while (1) {
   1909          					//__bis_SR_register(LPM3_bits + GIE);     // Enter LPM3
   1910          					//
   1911          					while ((fRxLineDownOn || fTimer50msOn) == 0) {}
   1912          					//
   1913          					if (fRxLineDownOn) {
   1914          						goto label_rx_continue;
   1915          					}
   1916          					if (fTimer50msOn) {						// Получен следующий 50мс интервал
   1917          						fTimer50msOn = 0;
   1918          						//
   1919          						if (uart_timer) {
   1920          							uart_timer--;
   1921          						}else{
   1922          							// End of Rx timeout
   1923          							//...
   1924          							INTER_IFG &= ~INTER_BIT;    	// Обнуляем флаг прерывания
   1925          							fRxLineDownOn = 0;
   1926          							break;
   1927          						}
   1928          					}
   1929          				}
   1930          			}
   1931          			//
   1932          			//
   1933          			BCSCTL1 = CALBC1_1MHZ; 					// Используем частоту 1 MГц
   1934          			DCOCTL =  CALDCO_1MHZ;
   1935          			//
   1936          			TA1CCR0  = 1 * SYS_TICK_TIME - 1;   	// Period T(us) * F(MHz)
   1937          			//
   1938          			//
   1939          		} // Soft UART Rx Hundler
   1940          	} // while(1)
   1941          }
   1942          
   1943          
   1944          
   1945          
   1946          //--------------------------------------------------------------------------------
   1947          // Function		: __interrupt void watchdog_timer (void)
   1948          // Parameters	: None
   1949          // Return		: None
   1950          // Description	: WDT Interrupt routine
   1951          //--------------------------------------------------------------------------------
   1952          #pragma vector=WDT_VECTOR
   1953          __interrupt void watchdog_timer (void) {
   1954          	
   1955          	if (fTimer50msOn) {
   1956          		if (++Timer50msCounter == 0) {		// > ~ 12sec
   1957          			WDTCTL = WDTCTL;				// Hardware RESET
   1958          		}
   1959          	}
   1960          	fTimer50msOn = 1;
   1961          	
   1962          	__bic_SR_register_on_exit(LPM3_bits);                   // Clear LPM3 bits from 0(SR)
   1963          }
   1964          
   1965          
   1966          
   1967          //--------------------------------------------------------------------------------
   1968          // Function		: __interrupt void CCR0_ISR(void)
   1969          // Parameters	: None
   1970          // Return		: None
   1971          // Description	: TIMER0 Interrupt routine
   1972          //--------------------------------------------------------------------------------
   1973          #pragma vector = TIMER0_A0_VECTOR
   1974          __interrupt void CCR0_ISR(void) {
   1975          
   1976          	fTimerA_On = 1;
   1977          	
   1978          } // CCR0_ISR
   1979          
   1980          
   1981          
   1982          //--------------------------------------------------------------------------------
   1983          // Function		: __interrupt void Timer_A1_ISR (void)
   1984          // Parameters	: None
   1985          // Return		: None
   1986          // Description	: TIMER1 Interrupt routine
   1987          //--------------------------------------------------------------------------------
   1988          #pragma vector=TIMER1_A0_VECTOR
   1989          __interrupt void Timer_A1_ISR (void)  {
   1990          	
   1991          	fTimerA1_On = 1;
   1992          	__bic_SR_register_on_exit(LPM3_bits);                   // Clear LPM3 bits from 0(SR)
   1993          } 
   1994          
   1995          
   1996          
   1997          //--------------------------------------------------------------------------------
   1998          // Function		: void Led_Flash(u16 duration)
   1999          // Parameters	: duration - duration Red LED flash in ms
   2000          // Return		: None
   2001          // Description	: Flashing red LED
   2002          //--------------------------------------------------------------------------------
   2003          void Led_Flash(u16 duration) {
   2004          	RED_SET();
   2005          	DelayMs(duration);
   2006          	RED_CLR();
   2007          }
   2008          
   2009          
   2010          
   2011          
   2012          
   2013          //--------------------------------------------------------------------------------
   2014          // Function		: u16 GetVCC(u8 boost_stop)
   2015          // Parameters	: boost_stop = 1 - if need call BoostStop() after measure
   2016          // Return		: Value in 10mV (for example 250 = 2.50V)
   2017          // Description	: Measurement the voltage VCC
   2018          //--------------------------------------------------------------------------------
   2019          u16 GetVCC(u8 boost_stop) {
   2020          	u16 res;	
   2021          	ADC_Measure(ADC_CH_VCC, 0, VCC_DATA_LEN);
   2022          	//~~~
   2023          	VREF_Off();
   2024          	//
   2025          	//	
   2026          	res = AverageData(adc_data1, VCC_DATA_LEN);
   2027          	res = res * 64 / 218 + 2;						//~~res = ((u32)res * 301) / 1024 & Compensation dV(R38)=20mV (max=302)
   2028          	return (res);			
   2029          }
   2030          
   2031          
   2032          
   2033          
   2034          //--------------------------------------------------------------------------------
   2035          // Function		: void VREF_On(void)
   2036          // Parameters	: None 
   2037          // Return		: None
   2038          // Description	: Enable VREF
   2039          //--------------------------------------------------------------------------------
   2040          void VREF_On(void) {
   2041          
   2042          	ADC10CTL0 = REFOUT + REFON + SREF_1 + MSC + ADC10ON;
   2043          	ADC10AE0 |= 0x10;                         // P1.4 ADC option select (VRef Out)
   2044          
   2045          }
   2046          
   2047          
   2048          
   2049          //--------------------------------------------------------------------------------
   2050          // Function		: void VREF_Off(void)
   2051          // Parameters	: None
   2052          // Return		: None
   2053          // Description	: Disable VREF
   2054          //--------------------------------------------------------------------------------
   2055          void VREF_Off(void) {
   2056          
   2057          	ADC10CTL0 = 0;							// Disable ADC & +VREF
   2058          	ADC10CTL0 = 0;							//
   2059          }
   2060          
   2061          
   2062          
   2063          //--------------------------------------------------------------------------------
   2064          // Function		: void ADC10_ISR(void)
   2065          // Parameters	: None
   2066          // Return		: None
   2067          // Description	: ADC10 interrupt service routine
   2068          //--------------------------------------------------------------------------------
   2069          #pragma vector=ADC10_VECTOR
   2070          __interrupt void ADC10_ISR(void) {
   2071          
   2072          	//ADC10AE0 &= ~0x0F;                      // Save only VRef Out
   2073          	
   2074          	adc_process = 0;
   2075          	
   2076          	fEndOfSamples = 1;
   2077          //	AMP_PWR_OFF();
   2078          	
   2079          	//__bic_SR_register_on_exit(CPUOFF);      // Clear CPUOFF bit from 0(SR)
   2080          	
   2081          }
   2082          
   2083          
   2084          
   2085          //--------------------------------------------------------------------------------
   2086          // Function		: u16 AverageData(u16 * data_ptr, u8 len)
   2087          // Parameters	: data_ptr - data array pointer, len - length of data array
   2088          // Return		: Average value of data
   2089          // Description	: Fuction calculate the average value of data array
   2090          //--------------------------------------------------------------------------------
   2091          u16 AverageData(u16 * data_ptr, u8 len) {
   2092          	u16 summa = 0;
   2093          	u8  i = len;
   2094          	while (i--) {
   2095          		summa += *data_ptr++;
   2096          	}
   2097          	//
   2098          	return (summa/len);
   2099          }
   2100          
   2101          
   2102          //--------------------------------------------------------------------------------
   2103          // Function		: void DeviceDiagnostics(void)
   2104          // Parameters	: None
   2105          // Return		: None
   2106          // Description	: Procedure of the diagnostics device
   2107          //--------------------------------------------------------------------------------
   2108          void DeviceDiagnostics(void) {
   2109          	//
   2110          	DelayMs(100);
   2111          	//
   2112          	//
   2113          		
   2114          #if (CRC_ENABLE == 1)
   2115          	// Check CS of Memory
   2116          	DeviceFault.fFaultCRC = 0;
   2117          	if (GetPropertiesCS() != CONFIG->CS) {
   2118          		DeviceFault.fFaultCRC = 1;
   2119          	}
   2120          #endif
   2121          }
   2122          
   2123          //--------------------------------------------------------------------------------
   2124          // Function		: u16 ADC_Measure_Simple(u16 ch, u16* buf, u8 count)
   2125          // Parameters	: refout = 0 or REFOUT, vref = REF1_5V , count - кол-во измерений 
   2126          // Return		: None
   2127          // Description	: Measurement of the current temperature of MCU
   2128          //--------------------------------------------------------------------------------
   2129          #pragma optimize=none
   2130          u16 ADC_Measure_Simple(u16 ch, u16* buf, u8 count) {
   2131          	u16 res;
   2132          
   2133          	while(adc_process) {}
   2134          	
   2135          	BUT_IE &= ~BUT_BIT;
   2136          	BUT_REN &= ~BUT_BIT; 		// PULL disable
   2137          	
   2138          	ADC10CTL0 = SREF_0 + ADC10SHT_1 + MSC  + ADC10ON + ADC10IE;	// Sample&hold = 8 x ADC10CLKs
   2139          	
   2140          	DelayUs(50);	
   2141          	//
   2142          	ADC10CTL1 = ADC10SSEL_2 + ADC10DIV_7 + CONSEQ_2 + ch;	// ADC_BUT;     // 
   2143          	//
   2144          	DelayUs(200);							// Delay to allow Ref to settle
   2145          
   2146          	ADC10DTC1 = count;						// count of conversions
   2147          	ADC10AE0 = ADC_AE_BUT;                 // A3 & A7 ADC option select
   2148          	//
   2149          	ADC10SA = (u16) &buf[0];          		// Data buffer start
   2150          	
   2151          	fEndOfSamples = 0;
   2152          	ADC10CTL0 |= ENC + ADC10SC;             // Sampling and conversion start
   2153          		
   2154          	__bis_SR_register(CPUOFF + GIE);        // LPM0, ADC10_ISR will force exit
   2155          	
   2156          	while (fEndOfSamples == 0){};
   2157          	fEndOfSamples = 0;
   2158          
   2159          	res = AverageData(buf, count);	
   2160          
   2161          	ADC10AE0 = ADC_AE;          // A3 & A7 ADC option select
   2162          	
   2163          	BUT_IFG &= ~BUT_BIT;    	// Обнуляем флаг прерывания
   2164          	BUT_IE |= BUT_BIT;
   2165          	BUT_REN |= BUT_BIT; 		// PULL enable
   2166          	
   2167          	return res;
   2168          }
   2169          
   2170          
   2171          //--------------------------------------------------------------------------------
   2172          // Function		: void u8 JP1_Define(void)
   2173          // Parameters	: None
   2174          // Return		: 0 - JP1 Open, 1 - JP1 Close
   2175          // Description	: Definition of JP1 state
   2176          //--------------------------------------------------------------------------------
   2177          void JP1_Define(void) {
   2178          	u16 buf[4];
   2179          	u16 res;
   2180          	
   2181          	res = ADC_Measure_Simple(ADC_BUT, buf, 4);
   2182          	
   2183          	if (res > 600) return; 
   2184          	if (res > 100) {
   2185          		jp1_state = 0;		// JP1 is Open 
   2186          	}else{
   2187          		jp1_state = 1;		// JP1 is Close
   2188          	}	
   2189          	//
   2190          	return;	
   2191          }
   2192          
   2193          
   2194          // End of main.c

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   ADC10_ISR
      4   ADC_MeasureInit
        6   -> DelayUs
      0   ADC_MeasureStart
     10   ADC_Measure_Simple
       10   -> AverageData
       10   -> DelayUs
       10 ?Epilogue4
      0   ADC_SetParam
      2   AMP_Gain_Init
        0   -> AMP_SetGain
      2   AbsValue
      2   AverageData
        0 ?DivMod16u
      4   CCR0_ISR
     22   CalibrationResultAnalise
       22   -> AMP_SetGain
       22   -> SetLevelsFromCalibr
       22   -> SetLimitCompens
       22   -> StoragePropertyByte
       22   -> StoragePropertyWord
       14 ?Epilogue6
      2   ClearDriftVar
      2   DefineNewMode
      2   DeviceDiagnostics
        2   -> DelayMs
        2   -> GetPropertiesCS
      2   DeviceStart
        4   -> SavePropertyCS
        6   -> StoragePropertyWord
      2   FaultSignalManager
      2   GetVCC
        2   -> ADC_Measure
        2 ?DivMod16u
     10   JP1_Define
       10   -> ADC_Measure_Simple
      2   LedTestValueManager
      2   Led_Flash
        2   -> DelayMs
      0   SetFaultMode
      6   SetLevels
        8   -> SavePropertyCS
       10   -> StoragePropertyWord
        6   -> StoragePropertyWord
        6 ?DivMod16s
        6 ?DivMod16u
      6   SetLevelsFromCalibr
        8   -> SavePropertyCS
       10   -> StoragePropertyWord
        6   -> StoragePropertyWord
        6 ?DivMod16s
        6 ?DivMod16u
      2   SetLimitCompens
        2   -> SavePropertyCS
        4   -> StoragePropertyWord
     34   SignalAnalysis
       30 ?DivMod16s
       30 ?DivMod32s
       14 ?Epilogue6
       34 ?Mul16to32s
      2   TimerA1_DelayUs
      0   Timer_A0_Off
      2   Timer_A0_SetDelay
      4   Timer_A1_ISR
      0   Timer_A1_Init
      2   VLO_GetPeriod
      0   VLO_TimerCalibr
        2   -> SavePropertyCS
        4   -> StoragePropertyWord
      2   VREF_Off
      2   VREF_On
     10   fir_filter
       10 ?DivMod32s
       10 ?Epilogue4
       10 ?Mul16to32s
      2   getZeroLevel
        0 ?DivMod16u
     18   main
       18   -> ADC_Measure_Simple
       18   -> AMP_SetGain
       18   -> CalibrationResultAnalise
       18   -> DelayMs
       20   -> DelayMs
       18   -> DelayUs
       20   -> DelayUs
       18   -> DelayUs_8MHz
       18   -> FaultSignalManager
       18   -> GPIO_Init
       18   -> STROB_IE_Enable
       20   -> SavePropertyCS
       18   -> SignalAnalysis
       18   -> SoftUART_ResetReceiveByte
       18   -> SoftUART_RxParse
       18   -> SoftUART_SetReceiveByte
       18   -> SoftUART_TxString
       20   -> SoftUART_TxString
       18   -> StoragePropertyWord
       22   -> StoragePropertyWord
       18   -> VLO_TimerCalibr
       18 ?DivMod16s
       18 ?DivMod16u
       20 ?DivMod16u
       18 ?DivMod32u
      4   watchdog_timer


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       8  ??Subroutine42_0
       6  ??Subroutine43_0
      22  ??Subroutine5_0
      38  ?Subroutine0
      20  ?Subroutine10
      12  ?Subroutine11
      10  ?Subroutine12
      18  ?Subroutine13
      16  ?Subroutine14
       4  ?Subroutine15
      24  ?Subroutine16
      16  ?Subroutine17
      10  ?Subroutine18
      10  ?Subroutine19
       8  ?Subroutine2
      28  ?Subroutine20
      20  ?Subroutine21
      18  ?Subroutine22
      14  ?Subroutine23
      36  ?Subroutine24
      18  ?Subroutine25
       8  ?Subroutine26
      10  ?Subroutine27
      14  ?Subroutine28
      64  ?Subroutine3
      12  ?Subroutine30
      20  ?Subroutine32
      28  ?Subroutine33
       8  ?Subroutine34
      14  ?Subroutine35
       8  ?Subroutine36
      16  ?Subroutine37
       8  ?Subroutine38
       6  ?Subroutine39
      24  ?Subroutine4
       8  ?Subroutine40
       8  ?Subroutine41
       8  ?Subroutine5
       2  ?Subroutine6
      12  ?Subroutine7
      12  ?Subroutine8
      16  ?Subroutine9
       1  ADC10AE0
       2  ADC10CTL0
       2  ADC10CTL1
       1  ADC10DTC1
       2  ADC10SA
      10  ADC10_ISR
       2  ADC10_ISR::??INTVEC 10
      58  ADC_MeasureInit
       0  ADC_MeasureStart
     140  ADC_Measure_Simple
       0  ADC_SetParam
       8  AMP_Gain_Init
      14  AbsValue
      22  AverageData
       1  BCSCTL1
       1  BCSCTL3
       1  CALBC1_16MHZ
       1  CALBC1_1MHZ
       1  CALBC1_8MHZ
       1  CALDCO_16MHZ
       1  CALDCO_1MHZ
       1  CALDCO_8MHZ
       4  CCR0_ISR
       2  CCR0_ISR::??INTVEC 18
       2  CCR1_Value
       1  CalibrFault
     420  CalibrationResultAnalise
       4  ClearDriftVar
       1  DCOCTL
       4  DefineNewMode
      32  DeviceDiagnostics
       1  DeviceFault
       1  DeviceMode
      12  DeviceStart
       2  DriftCounter
       4  DriftLevel
       4  DriftSumma
      18  FIRCoef
     266  FaultSignalManager
       1  FireMeasCount
      74  GetVCC
       1  IE1
       1  IFG1
      36  JP1_Define
      88  LedTestValueManager
       8  Led_Flash
       1  P1OUT
       1  P2IE
       1  P2IFG
       1  P2IN
       1  P2OUT
       1  P2REN
       0  SetFaultMode
      22  SetLevels
      64  SetLevelsFromCalibr
      20  SetLimitCompens
     690  SignalAnalysis
       2  TA0CCR0
       2  TA0CCTL0
       2  TA0CCTL1
       2  TA0CTL
       2  TA0R
       2  TA1CCR0
       2  TA1CCTL0
       2  TA1CTL
       2  TA1R
       1  Timer50msCounter
      40  TimerA1_DelayUs
       0  Timer_A0_Off
      24  Timer_A0_SetDelay
       6  Timer_A1_ISR
       2  Timer_A1_ISR::??INTVEC 26
       0  Timer_A1_Init
      30  VLO_GetPeriod
       0  VLO_TimerCalibr
      10  VREF_Off
      14  VREF_On
       2  WDTCTL
      32  adc_data1
       1  adc_process
       1  amp_no
      18  calibr_sequence
       1  calibr_stage
       2  cfg_reg
       2  d1
       2  d2
       2  d3
       2  d4
       2  dark
       2  delta
       2  delta_last
       2  f
       1  fTimerA1_On
       1  fault_chain_ind
       2  fault_chain_timer
       1  fault_chamber_counter
       1  fault_phase
       8  fault_sequence
       2  fault_timer
     112  fir_filter
       2  flash_period_timer
       1  gain
      12  getZeroLevel
       2  hi_signal_counter
       1  jp1_state
       2  last_0_level
       2  last_level
       4  led_r
       4  led_sh
       4  led_y
       1  light_sync
       2  light_timer
    2322  main
       2  mainPeriodCounter
       6  q_array
       1  reference
      12  s_array
     200  signal_array
       2  start_timer
       1  strob_fault_phase
       2  strob_pulse_timer
       2  timerKeyDown
       2  timerLongPeriod
       2  timerMain
      18  watchdog_timer
       2  watchdog_timer::??INTVEC 20
      36  x
       2  zero_timer

 
 5 246 bytes in segment CODE
    45 bytes in segment DATA16_AN
    44 bytes in segment DATA16_C
   371 bytes in segment DATA16_Z
     8 bytes in segment INTVEC
     2 bytes in segment REGVAR_AN
 
 5 246 bytes of CODE     memory
    44 bytes of CONST    memory (+  8 bytes shared)
   371 bytes of DATA     memory (+ 45 bytes shared)
     0 bytes of REGISTER memory (+  2 bytes shared)

Errors: none
Warnings: 7
